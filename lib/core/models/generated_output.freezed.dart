// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'generated_output.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

GeneratedOutput _$GeneratedOutputFromJson(Map<String, dynamic> json) {
  return _GeneratedOutput.fromJson(json);
}

/// @nodoc
mixin _$GeneratedOutput {
  StoryOutput get story => throw _privateConstructorUsedError;
  IdentificationOutput get identification => throw _privateConstructorUsedError;
  FunctioningOutput get functioning => throw _privateConstructorUsedError;
  ActionsOutput get actions => throw _privateConstructorUsedError;
  LifeDomainsOutput get lifeDomains => throw _privateConstructorUsedError;
  MetaOutput get meta => throw _privateConstructorUsedError;
  ExamplesOutput? get examples => throw _privateConstructorUsedError;
  @JsonKey(name: 'identification_v2')
  IdentificationV2? get identificationV2 => throw _privateConstructorUsedError; // Center/Orbit system
  DeltaSummary? get deltaSummary => throw _privateConstructorUsedError;

  /// Serializes this GeneratedOutput to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GeneratedOutputCopyWith<GeneratedOutput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeneratedOutputCopyWith<$Res> {
  factory $GeneratedOutputCopyWith(
    GeneratedOutput value,
    $Res Function(GeneratedOutput) then,
  ) = _$GeneratedOutputCopyWithImpl<$Res, GeneratedOutput>;
  @useResult
  $Res call({
    StoryOutput story,
    IdentificationOutput identification,
    FunctioningOutput functioning,
    ActionsOutput actions,
    LifeDomainsOutput lifeDomains,
    MetaOutput meta,
    ExamplesOutput? examples,
    @JsonKey(name: 'identification_v2') IdentificationV2? identificationV2,
    DeltaSummary? deltaSummary,
  });

  $StoryOutputCopyWith<$Res> get story;
  $IdentificationOutputCopyWith<$Res> get identification;
  $FunctioningOutputCopyWith<$Res> get functioning;
  $ActionsOutputCopyWith<$Res> get actions;
  $LifeDomainsOutputCopyWith<$Res> get lifeDomains;
  $MetaOutputCopyWith<$Res> get meta;
  $ExamplesOutputCopyWith<$Res>? get examples;
  $IdentificationV2CopyWith<$Res>? get identificationV2;
  $DeltaSummaryCopyWith<$Res>? get deltaSummary;
}

/// @nodoc
class _$GeneratedOutputCopyWithImpl<$Res, $Val extends GeneratedOutput>
    implements $GeneratedOutputCopyWith<$Res> {
  _$GeneratedOutputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? story = null,
    Object? identification = null,
    Object? functioning = null,
    Object? actions = null,
    Object? lifeDomains = null,
    Object? meta = null,
    Object? examples = freezed,
    Object? identificationV2 = freezed,
    Object? deltaSummary = freezed,
  }) {
    return _then(
      _value.copyWith(
            story: null == story
                ? _value.story
                : story // ignore: cast_nullable_to_non_nullable
                      as StoryOutput,
            identification: null == identification
                ? _value.identification
                : identification // ignore: cast_nullable_to_non_nullable
                      as IdentificationOutput,
            functioning: null == functioning
                ? _value.functioning
                : functioning // ignore: cast_nullable_to_non_nullable
                      as FunctioningOutput,
            actions: null == actions
                ? _value.actions
                : actions // ignore: cast_nullable_to_non_nullable
                      as ActionsOutput,
            lifeDomains: null == lifeDomains
                ? _value.lifeDomains
                : lifeDomains // ignore: cast_nullable_to_non_nullable
                      as LifeDomainsOutput,
            meta: null == meta
                ? _value.meta
                : meta // ignore: cast_nullable_to_non_nullable
                      as MetaOutput,
            examples: freezed == examples
                ? _value.examples
                : examples // ignore: cast_nullable_to_non_nullable
                      as ExamplesOutput?,
            identificationV2: freezed == identificationV2
                ? _value.identificationV2
                : identificationV2 // ignore: cast_nullable_to_non_nullable
                      as IdentificationV2?,
            deltaSummary: freezed == deltaSummary
                ? _value.deltaSummary
                : deltaSummary // ignore: cast_nullable_to_non_nullable
                      as DeltaSummary?,
          )
          as $Val,
    );
  }

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StoryOutputCopyWith<$Res> get story {
    return $StoryOutputCopyWith<$Res>(_value.story, (value) {
      return _then(_value.copyWith(story: value) as $Val);
    });
  }

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $IdentificationOutputCopyWith<$Res> get identification {
    return $IdentificationOutputCopyWith<$Res>(_value.identification, (value) {
      return _then(_value.copyWith(identification: value) as $Val);
    });
  }

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FunctioningOutputCopyWith<$Res> get functioning {
    return $FunctioningOutputCopyWith<$Res>(_value.functioning, (value) {
      return _then(_value.copyWith(functioning: value) as $Val);
    });
  }

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ActionsOutputCopyWith<$Res> get actions {
    return $ActionsOutputCopyWith<$Res>(_value.actions, (value) {
      return _then(_value.copyWith(actions: value) as $Val);
    });
  }

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LifeDomainsOutputCopyWith<$Res> get lifeDomains {
    return $LifeDomainsOutputCopyWith<$Res>(_value.lifeDomains, (value) {
      return _then(_value.copyWith(lifeDomains: value) as $Val);
    });
  }

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MetaOutputCopyWith<$Res> get meta {
    return $MetaOutputCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ExamplesOutputCopyWith<$Res>? get examples {
    if (_value.examples == null) {
      return null;
    }

    return $ExamplesOutputCopyWith<$Res>(_value.examples!, (value) {
      return _then(_value.copyWith(examples: value) as $Val);
    });
  }

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $IdentificationV2CopyWith<$Res>? get identificationV2 {
    if (_value.identificationV2 == null) {
      return null;
    }

    return $IdentificationV2CopyWith<$Res>(_value.identificationV2!, (value) {
      return _then(_value.copyWith(identificationV2: value) as $Val);
    });
  }

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DeltaSummaryCopyWith<$Res>? get deltaSummary {
    if (_value.deltaSummary == null) {
      return null;
    }

    return $DeltaSummaryCopyWith<$Res>(_value.deltaSummary!, (value) {
      return _then(_value.copyWith(deltaSummary: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$GeneratedOutputImplCopyWith<$Res>
    implements $GeneratedOutputCopyWith<$Res> {
  factory _$$GeneratedOutputImplCopyWith(
    _$GeneratedOutputImpl value,
    $Res Function(_$GeneratedOutputImpl) then,
  ) = __$$GeneratedOutputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    StoryOutput story,
    IdentificationOutput identification,
    FunctioningOutput functioning,
    ActionsOutput actions,
    LifeDomainsOutput lifeDomains,
    MetaOutput meta,
    ExamplesOutput? examples,
    @JsonKey(name: 'identification_v2') IdentificationV2? identificationV2,
    DeltaSummary? deltaSummary,
  });

  @override
  $StoryOutputCopyWith<$Res> get story;
  @override
  $IdentificationOutputCopyWith<$Res> get identification;
  @override
  $FunctioningOutputCopyWith<$Res> get functioning;
  @override
  $ActionsOutputCopyWith<$Res> get actions;
  @override
  $LifeDomainsOutputCopyWith<$Res> get lifeDomains;
  @override
  $MetaOutputCopyWith<$Res> get meta;
  @override
  $ExamplesOutputCopyWith<$Res>? get examples;
  @override
  $IdentificationV2CopyWith<$Res>? get identificationV2;
  @override
  $DeltaSummaryCopyWith<$Res>? get deltaSummary;
}

/// @nodoc
class __$$GeneratedOutputImplCopyWithImpl<$Res>
    extends _$GeneratedOutputCopyWithImpl<$Res, _$GeneratedOutputImpl>
    implements _$$GeneratedOutputImplCopyWith<$Res> {
  __$$GeneratedOutputImplCopyWithImpl(
    _$GeneratedOutputImpl _value,
    $Res Function(_$GeneratedOutputImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? story = null,
    Object? identification = null,
    Object? functioning = null,
    Object? actions = null,
    Object? lifeDomains = null,
    Object? meta = null,
    Object? examples = freezed,
    Object? identificationV2 = freezed,
    Object? deltaSummary = freezed,
  }) {
    return _then(
      _$GeneratedOutputImpl(
        story: null == story
            ? _value.story
            : story // ignore: cast_nullable_to_non_nullable
                  as StoryOutput,
        identification: null == identification
            ? _value.identification
            : identification // ignore: cast_nullable_to_non_nullable
                  as IdentificationOutput,
        functioning: null == functioning
            ? _value.functioning
            : functioning // ignore: cast_nullable_to_non_nullable
                  as FunctioningOutput,
        actions: null == actions
            ? _value.actions
            : actions // ignore: cast_nullable_to_non_nullable
                  as ActionsOutput,
        lifeDomains: null == lifeDomains
            ? _value.lifeDomains
            : lifeDomains // ignore: cast_nullable_to_non_nullable
                  as LifeDomainsOutput,
        meta: null == meta
            ? _value.meta
            : meta // ignore: cast_nullable_to_non_nullable
                  as MetaOutput,
        examples: freezed == examples
            ? _value.examples
            : examples // ignore: cast_nullable_to_non_nullable
                  as ExamplesOutput?,
        identificationV2: freezed == identificationV2
            ? _value.identificationV2
            : identificationV2 // ignore: cast_nullable_to_non_nullable
                  as IdentificationV2?,
        deltaSummary: freezed == deltaSummary
            ? _value.deltaSummary
            : deltaSummary // ignore: cast_nullable_to_non_nullable
                  as DeltaSummary?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$GeneratedOutputImpl implements _GeneratedOutput {
  const _$GeneratedOutputImpl({
    required this.story,
    required this.identification,
    required this.functioning,
    required this.actions,
    required this.lifeDomains,
    required this.meta,
    this.examples,
    @JsonKey(name: 'identification_v2') this.identificationV2,
    this.deltaSummary,
  });

  factory _$GeneratedOutputImpl.fromJson(Map<String, dynamic> json) =>
      _$$GeneratedOutputImplFromJson(json);

  @override
  final StoryOutput story;
  @override
  final IdentificationOutput identification;
  @override
  final FunctioningOutput functioning;
  @override
  final ActionsOutput actions;
  @override
  final LifeDomainsOutput lifeDomains;
  @override
  final MetaOutput meta;
  @override
  final ExamplesOutput? examples;
  @override
  @JsonKey(name: 'identification_v2')
  final IdentificationV2? identificationV2;
  // Center/Orbit system
  @override
  final DeltaSummary? deltaSummary;

  @override
  String toString() {
    return 'GeneratedOutput(story: $story, identification: $identification, functioning: $functioning, actions: $actions, lifeDomains: $lifeDomains, meta: $meta, examples: $examples, identificationV2: $identificationV2, deltaSummary: $deltaSummary)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GeneratedOutputImpl &&
            (identical(other.story, story) || other.story == story) &&
            (identical(other.identification, identification) ||
                other.identification == identification) &&
            (identical(other.functioning, functioning) ||
                other.functioning == functioning) &&
            (identical(other.actions, actions) || other.actions == actions) &&
            (identical(other.lifeDomains, lifeDomains) ||
                other.lifeDomains == lifeDomains) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.examples, examples) ||
                other.examples == examples) &&
            (identical(other.identificationV2, identificationV2) ||
                other.identificationV2 == identificationV2) &&
            (identical(other.deltaSummary, deltaSummary) ||
                other.deltaSummary == deltaSummary));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    story,
    identification,
    functioning,
    actions,
    lifeDomains,
    meta,
    examples,
    identificationV2,
    deltaSummary,
  );

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GeneratedOutputImplCopyWith<_$GeneratedOutputImpl> get copyWith =>
      __$$GeneratedOutputImplCopyWithImpl<_$GeneratedOutputImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$GeneratedOutputImplToJson(this);
  }
}

abstract class _GeneratedOutput implements GeneratedOutput {
  const factory _GeneratedOutput({
    required final StoryOutput story,
    required final IdentificationOutput identification,
    required final FunctioningOutput functioning,
    required final ActionsOutput actions,
    required final LifeDomainsOutput lifeDomains,
    required final MetaOutput meta,
    final ExamplesOutput? examples,
    @JsonKey(name: 'identification_v2')
    final IdentificationV2? identificationV2,
    final DeltaSummary? deltaSummary,
  }) = _$GeneratedOutputImpl;

  factory _GeneratedOutput.fromJson(Map<String, dynamic> json) =
      _$GeneratedOutputImpl.fromJson;

  @override
  StoryOutput get story;
  @override
  IdentificationOutput get identification;
  @override
  FunctioningOutput get functioning;
  @override
  ActionsOutput get actions;
  @override
  LifeDomainsOutput get lifeDomains;
  @override
  MetaOutput get meta;
  @override
  ExamplesOutput? get examples;
  @override
  @JsonKey(name: 'identification_v2')
  IdentificationV2? get identificationV2; // Center/Orbit system
  @override
  DeltaSummary? get deltaSummary;

  /// Create a copy of GeneratedOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GeneratedOutputImplCopyWith<_$GeneratedOutputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

StoryOutput _$StoryOutputFromJson(Map<String, dynamic> json) {
  return _StoryOutput.fromJson(json);
}

/// @nodoc
mixin _$StoryOutput {
  String get mythSummary => throw _privateConstructorUsedError;
  String get centralTension => throw _privateConstructorUsedError;
  String get guidingSentence => throw _privateConstructorUsedError;
  String? get northStarScene => throw _privateConstructorUsedError;
  String? get currentChapter => throw _privateConstructorUsedError;

  /// Serializes this StoryOutput to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of StoryOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StoryOutputCopyWith<StoryOutput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StoryOutputCopyWith<$Res> {
  factory $StoryOutputCopyWith(
    StoryOutput value,
    $Res Function(StoryOutput) then,
  ) = _$StoryOutputCopyWithImpl<$Res, StoryOutput>;
  @useResult
  $Res call({
    String mythSummary,
    String centralTension,
    String guidingSentence,
    String? northStarScene,
    String? currentChapter,
  });
}

/// @nodoc
class _$StoryOutputCopyWithImpl<$Res, $Val extends StoryOutput>
    implements $StoryOutputCopyWith<$Res> {
  _$StoryOutputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StoryOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mythSummary = null,
    Object? centralTension = null,
    Object? guidingSentence = null,
    Object? northStarScene = freezed,
    Object? currentChapter = freezed,
  }) {
    return _then(
      _value.copyWith(
            mythSummary: null == mythSummary
                ? _value.mythSummary
                : mythSummary // ignore: cast_nullable_to_non_nullable
                      as String,
            centralTension: null == centralTension
                ? _value.centralTension
                : centralTension // ignore: cast_nullable_to_non_nullable
                      as String,
            guidingSentence: null == guidingSentence
                ? _value.guidingSentence
                : guidingSentence // ignore: cast_nullable_to_non_nullable
                      as String,
            northStarScene: freezed == northStarScene
                ? _value.northStarScene
                : northStarScene // ignore: cast_nullable_to_non_nullable
                      as String?,
            currentChapter: freezed == currentChapter
                ? _value.currentChapter
                : currentChapter // ignore: cast_nullable_to_non_nullable
                      as String?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$StoryOutputImplCopyWith<$Res>
    implements $StoryOutputCopyWith<$Res> {
  factory _$$StoryOutputImplCopyWith(
    _$StoryOutputImpl value,
    $Res Function(_$StoryOutputImpl) then,
  ) = __$$StoryOutputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String mythSummary,
    String centralTension,
    String guidingSentence,
    String? northStarScene,
    String? currentChapter,
  });
}

/// @nodoc
class __$$StoryOutputImplCopyWithImpl<$Res>
    extends _$StoryOutputCopyWithImpl<$Res, _$StoryOutputImpl>
    implements _$$StoryOutputImplCopyWith<$Res> {
  __$$StoryOutputImplCopyWithImpl(
    _$StoryOutputImpl _value,
    $Res Function(_$StoryOutputImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of StoryOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mythSummary = null,
    Object? centralTension = null,
    Object? guidingSentence = null,
    Object? northStarScene = freezed,
    Object? currentChapter = freezed,
  }) {
    return _then(
      _$StoryOutputImpl(
        mythSummary: null == mythSummary
            ? _value.mythSummary
            : mythSummary // ignore: cast_nullable_to_non_nullable
                  as String,
        centralTension: null == centralTension
            ? _value.centralTension
            : centralTension // ignore: cast_nullable_to_non_nullable
                  as String,
        guidingSentence: null == guidingSentence
            ? _value.guidingSentence
            : guidingSentence // ignore: cast_nullable_to_non_nullable
                  as String,
        northStarScene: freezed == northStarScene
            ? _value.northStarScene
            : northStarScene // ignore: cast_nullable_to_non_nullable
                  as String?,
        currentChapter: freezed == currentChapter
            ? _value.currentChapter
            : currentChapter // ignore: cast_nullable_to_non_nullable
                  as String?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$StoryOutputImpl implements _StoryOutput {
  const _$StoryOutputImpl({
    required this.mythSummary,
    required this.centralTension,
    required this.guidingSentence,
    this.northStarScene,
    this.currentChapter,
  });

  factory _$StoryOutputImpl.fromJson(Map<String, dynamic> json) =>
      _$$StoryOutputImplFromJson(json);

  @override
  final String mythSummary;
  @override
  final String centralTension;
  @override
  final String guidingSentence;
  @override
  final String? northStarScene;
  @override
  final String? currentChapter;

  @override
  String toString() {
    return 'StoryOutput(mythSummary: $mythSummary, centralTension: $centralTension, guidingSentence: $guidingSentence, northStarScene: $northStarScene, currentChapter: $currentChapter)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StoryOutputImpl &&
            (identical(other.mythSummary, mythSummary) ||
                other.mythSummary == mythSummary) &&
            (identical(other.centralTension, centralTension) ||
                other.centralTension == centralTension) &&
            (identical(other.guidingSentence, guidingSentence) ||
                other.guidingSentence == guidingSentence) &&
            (identical(other.northStarScene, northStarScene) ||
                other.northStarScene == northStarScene) &&
            (identical(other.currentChapter, currentChapter) ||
                other.currentChapter == currentChapter));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    mythSummary,
    centralTension,
    guidingSentence,
    northStarScene,
    currentChapter,
  );

  /// Create a copy of StoryOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StoryOutputImplCopyWith<_$StoryOutputImpl> get copyWith =>
      __$$StoryOutputImplCopyWithImpl<_$StoryOutputImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StoryOutputImplToJson(this);
  }
}

abstract class _StoryOutput implements StoryOutput {
  const factory _StoryOutput({
    required final String mythSummary,
    required final String centralTension,
    required final String guidingSentence,
    final String? northStarScene,
    final String? currentChapter,
  }) = _$StoryOutputImpl;

  factory _StoryOutput.fromJson(Map<String, dynamic> json) =
      _$StoryOutputImpl.fromJson;

  @override
  String get mythSummary;
  @override
  String get centralTension;
  @override
  String get guidingSentence;
  @override
  String? get northStarScene;
  @override
  String? get currentChapter;

  /// Create a copy of StoryOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StoryOutputImplCopyWith<_$StoryOutputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

IdentificationOutput _$IdentificationOutputFromJson(Map<String, dynamic> json) {
  return _IdentificationOutput.fromJson(json);
}

/// @nodoc
mixin _$IdentificationOutput {
  ArchetypeBlock get ego => throw _privateConstructorUsedError;
  ArchetypeBlock get persona => throw _privateConstructorUsedError;
  ArchetypeBlock get shadow => throw _privateConstructorUsedError;
  ArchetypeBlock? get shadowVirtue => throw _privateConstructorUsedError;
  ArchetypeBlock get feelingFunction => throw _privateConstructorUsedError;
  ArchetypeBlock? get erosAxis => throw _privateConstructorUsedError;
  ArchetypeBlock? get moralOrientation => throw _privateConstructorUsedError;
  List<EvidenceItem> get evidence => throw _privateConstructorUsedError;

  /// Serializes this IdentificationOutput to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of IdentificationOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $IdentificationOutputCopyWith<IdentificationOutput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IdentificationOutputCopyWith<$Res> {
  factory $IdentificationOutputCopyWith(
    IdentificationOutput value,
    $Res Function(IdentificationOutput) then,
  ) = _$IdentificationOutputCopyWithImpl<$Res, IdentificationOutput>;
  @useResult
  $Res call({
    ArchetypeBlock ego,
    ArchetypeBlock persona,
    ArchetypeBlock shadow,
    ArchetypeBlock? shadowVirtue,
    ArchetypeBlock feelingFunction,
    ArchetypeBlock? erosAxis,
    ArchetypeBlock? moralOrientation,
    List<EvidenceItem> evidence,
  });

  $ArchetypeBlockCopyWith<$Res> get ego;
  $ArchetypeBlockCopyWith<$Res> get persona;
  $ArchetypeBlockCopyWith<$Res> get shadow;
  $ArchetypeBlockCopyWith<$Res>? get shadowVirtue;
  $ArchetypeBlockCopyWith<$Res> get feelingFunction;
  $ArchetypeBlockCopyWith<$Res>? get erosAxis;
  $ArchetypeBlockCopyWith<$Res>? get moralOrientation;
}

/// @nodoc
class _$IdentificationOutputCopyWithImpl<
  $Res,
  $Val extends IdentificationOutput
>
    implements $IdentificationOutputCopyWith<$Res> {
  _$IdentificationOutputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of IdentificationOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ego = null,
    Object? persona = null,
    Object? shadow = null,
    Object? shadowVirtue = freezed,
    Object? feelingFunction = null,
    Object? erosAxis = freezed,
    Object? moralOrientation = freezed,
    Object? evidence = null,
  }) {
    return _then(
      _value.copyWith(
            ego: null == ego
                ? _value.ego
                : ego // ignore: cast_nullable_to_non_nullable
                      as ArchetypeBlock,
            persona: null == persona
                ? _value.persona
                : persona // ignore: cast_nullable_to_non_nullable
                      as ArchetypeBlock,
            shadow: null == shadow
                ? _value.shadow
                : shadow // ignore: cast_nullable_to_non_nullable
                      as ArchetypeBlock,
            shadowVirtue: freezed == shadowVirtue
                ? _value.shadowVirtue
                : shadowVirtue // ignore: cast_nullable_to_non_nullable
                      as ArchetypeBlock?,
            feelingFunction: null == feelingFunction
                ? _value.feelingFunction
                : feelingFunction // ignore: cast_nullable_to_non_nullable
                      as ArchetypeBlock,
            erosAxis: freezed == erosAxis
                ? _value.erosAxis
                : erosAxis // ignore: cast_nullable_to_non_nullable
                      as ArchetypeBlock?,
            moralOrientation: freezed == moralOrientation
                ? _value.moralOrientation
                : moralOrientation // ignore: cast_nullable_to_non_nullable
                      as ArchetypeBlock?,
            evidence: null == evidence
                ? _value.evidence
                : evidence // ignore: cast_nullable_to_non_nullable
                      as List<EvidenceItem>,
          )
          as $Val,
    );
  }

  /// Create a copy of IdentificationOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArchetypeBlockCopyWith<$Res> get ego {
    return $ArchetypeBlockCopyWith<$Res>(_value.ego, (value) {
      return _then(_value.copyWith(ego: value) as $Val);
    });
  }

  /// Create a copy of IdentificationOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArchetypeBlockCopyWith<$Res> get persona {
    return $ArchetypeBlockCopyWith<$Res>(_value.persona, (value) {
      return _then(_value.copyWith(persona: value) as $Val);
    });
  }

  /// Create a copy of IdentificationOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArchetypeBlockCopyWith<$Res> get shadow {
    return $ArchetypeBlockCopyWith<$Res>(_value.shadow, (value) {
      return _then(_value.copyWith(shadow: value) as $Val);
    });
  }

  /// Create a copy of IdentificationOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArchetypeBlockCopyWith<$Res>? get shadowVirtue {
    if (_value.shadowVirtue == null) {
      return null;
    }

    return $ArchetypeBlockCopyWith<$Res>(_value.shadowVirtue!, (value) {
      return _then(_value.copyWith(shadowVirtue: value) as $Val);
    });
  }

  /// Create a copy of IdentificationOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArchetypeBlockCopyWith<$Res> get feelingFunction {
    return $ArchetypeBlockCopyWith<$Res>(_value.feelingFunction, (value) {
      return _then(_value.copyWith(feelingFunction: value) as $Val);
    });
  }

  /// Create a copy of IdentificationOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArchetypeBlockCopyWith<$Res>? get erosAxis {
    if (_value.erosAxis == null) {
      return null;
    }

    return $ArchetypeBlockCopyWith<$Res>(_value.erosAxis!, (value) {
      return _then(_value.copyWith(erosAxis: value) as $Val);
    });
  }

  /// Create a copy of IdentificationOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArchetypeBlockCopyWith<$Res>? get moralOrientation {
    if (_value.moralOrientation == null) {
      return null;
    }

    return $ArchetypeBlockCopyWith<$Res>(_value.moralOrientation!, (value) {
      return _then(_value.copyWith(moralOrientation: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$IdentificationOutputImplCopyWith<$Res>
    implements $IdentificationOutputCopyWith<$Res> {
  factory _$$IdentificationOutputImplCopyWith(
    _$IdentificationOutputImpl value,
    $Res Function(_$IdentificationOutputImpl) then,
  ) = __$$IdentificationOutputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    ArchetypeBlock ego,
    ArchetypeBlock persona,
    ArchetypeBlock shadow,
    ArchetypeBlock? shadowVirtue,
    ArchetypeBlock feelingFunction,
    ArchetypeBlock? erosAxis,
    ArchetypeBlock? moralOrientation,
    List<EvidenceItem> evidence,
  });

  @override
  $ArchetypeBlockCopyWith<$Res> get ego;
  @override
  $ArchetypeBlockCopyWith<$Res> get persona;
  @override
  $ArchetypeBlockCopyWith<$Res> get shadow;
  @override
  $ArchetypeBlockCopyWith<$Res>? get shadowVirtue;
  @override
  $ArchetypeBlockCopyWith<$Res> get feelingFunction;
  @override
  $ArchetypeBlockCopyWith<$Res>? get erosAxis;
  @override
  $ArchetypeBlockCopyWith<$Res>? get moralOrientation;
}

/// @nodoc
class __$$IdentificationOutputImplCopyWithImpl<$Res>
    extends _$IdentificationOutputCopyWithImpl<$Res, _$IdentificationOutputImpl>
    implements _$$IdentificationOutputImplCopyWith<$Res> {
  __$$IdentificationOutputImplCopyWithImpl(
    _$IdentificationOutputImpl _value,
    $Res Function(_$IdentificationOutputImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of IdentificationOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ego = null,
    Object? persona = null,
    Object? shadow = null,
    Object? shadowVirtue = freezed,
    Object? feelingFunction = null,
    Object? erosAxis = freezed,
    Object? moralOrientation = freezed,
    Object? evidence = null,
  }) {
    return _then(
      _$IdentificationOutputImpl(
        ego: null == ego
            ? _value.ego
            : ego // ignore: cast_nullable_to_non_nullable
                  as ArchetypeBlock,
        persona: null == persona
            ? _value.persona
            : persona // ignore: cast_nullable_to_non_nullable
                  as ArchetypeBlock,
        shadow: null == shadow
            ? _value.shadow
            : shadow // ignore: cast_nullable_to_non_nullable
                  as ArchetypeBlock,
        shadowVirtue: freezed == shadowVirtue
            ? _value.shadowVirtue
            : shadowVirtue // ignore: cast_nullable_to_non_nullable
                  as ArchetypeBlock?,
        feelingFunction: null == feelingFunction
            ? _value.feelingFunction
            : feelingFunction // ignore: cast_nullable_to_non_nullable
                  as ArchetypeBlock,
        erosAxis: freezed == erosAxis
            ? _value.erosAxis
            : erosAxis // ignore: cast_nullable_to_non_nullable
                  as ArchetypeBlock?,
        moralOrientation: freezed == moralOrientation
            ? _value.moralOrientation
            : moralOrientation // ignore: cast_nullable_to_non_nullable
                  as ArchetypeBlock?,
        evidence: null == evidence
            ? _value._evidence
            : evidence // ignore: cast_nullable_to_non_nullable
                  as List<EvidenceItem>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$IdentificationOutputImpl implements _IdentificationOutput {
  const _$IdentificationOutputImpl({
    required this.ego,
    required this.persona,
    required this.shadow,
    this.shadowVirtue,
    required this.feelingFunction,
    this.erosAxis,
    this.moralOrientation,
    final List<EvidenceItem> evidence = const [],
  }) : _evidence = evidence;

  factory _$IdentificationOutputImpl.fromJson(Map<String, dynamic> json) =>
      _$$IdentificationOutputImplFromJson(json);

  @override
  final ArchetypeBlock ego;
  @override
  final ArchetypeBlock persona;
  @override
  final ArchetypeBlock shadow;
  @override
  final ArchetypeBlock? shadowVirtue;
  @override
  final ArchetypeBlock feelingFunction;
  @override
  final ArchetypeBlock? erosAxis;
  @override
  final ArchetypeBlock? moralOrientation;
  final List<EvidenceItem> _evidence;
  @override
  @JsonKey()
  List<EvidenceItem> get evidence {
    if (_evidence is EqualUnmodifiableListView) return _evidence;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_evidence);
  }

  @override
  String toString() {
    return 'IdentificationOutput(ego: $ego, persona: $persona, shadow: $shadow, shadowVirtue: $shadowVirtue, feelingFunction: $feelingFunction, erosAxis: $erosAxis, moralOrientation: $moralOrientation, evidence: $evidence)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IdentificationOutputImpl &&
            (identical(other.ego, ego) || other.ego == ego) &&
            (identical(other.persona, persona) || other.persona == persona) &&
            (identical(other.shadow, shadow) || other.shadow == shadow) &&
            (identical(other.shadowVirtue, shadowVirtue) ||
                other.shadowVirtue == shadowVirtue) &&
            (identical(other.feelingFunction, feelingFunction) ||
                other.feelingFunction == feelingFunction) &&
            (identical(other.erosAxis, erosAxis) ||
                other.erosAxis == erosAxis) &&
            (identical(other.moralOrientation, moralOrientation) ||
                other.moralOrientation == moralOrientation) &&
            const DeepCollectionEquality().equals(other._evidence, _evidence));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    ego,
    persona,
    shadow,
    shadowVirtue,
    feelingFunction,
    erosAxis,
    moralOrientation,
    const DeepCollectionEquality().hash(_evidence),
  );

  /// Create a copy of IdentificationOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IdentificationOutputImplCopyWith<_$IdentificationOutputImpl>
  get copyWith =>
      __$$IdentificationOutputImplCopyWithImpl<_$IdentificationOutputImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$IdentificationOutputImplToJson(this);
  }
}

abstract class _IdentificationOutput implements IdentificationOutput {
  const factory _IdentificationOutput({
    required final ArchetypeBlock ego,
    required final ArchetypeBlock persona,
    required final ArchetypeBlock shadow,
    final ArchetypeBlock? shadowVirtue,
    required final ArchetypeBlock feelingFunction,
    final ArchetypeBlock? erosAxis,
    final ArchetypeBlock? moralOrientation,
    final List<EvidenceItem> evidence,
  }) = _$IdentificationOutputImpl;

  factory _IdentificationOutput.fromJson(Map<String, dynamic> json) =
      _$IdentificationOutputImpl.fromJson;

  @override
  ArchetypeBlock get ego;
  @override
  ArchetypeBlock get persona;
  @override
  ArchetypeBlock get shadow;
  @override
  ArchetypeBlock? get shadowVirtue;
  @override
  ArchetypeBlock get feelingFunction;
  @override
  ArchetypeBlock? get erosAxis;
  @override
  ArchetypeBlock? get moralOrientation;
  @override
  List<EvidenceItem> get evidence;

  /// Create a copy of IdentificationOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IdentificationOutputImplCopyWith<_$IdentificationOutputImpl>
  get copyWith => throw _privateConstructorUsedError;
}

FunctioningOutput _$FunctioningOutputFromJson(Map<String, dynamic> json) {
  return _FunctioningOutput.fromJson(json);
}

/// @nodoc
mixin _$FunctioningOutput {
  List<String> get coreTraits => throw _privateConstructorUsedError;
  String get symbolicEssence => throw _privateConstructorUsedError;
  String get narrativeArc => throw _privateConstructorUsedError;
  String get redemptionArc => throw _privateConstructorUsedError;
  @CostsConverter()
  String? get costsAndCompensations => throw _privateConstructorUsedError;
  String? get powerStance => throw _privateConstructorUsedError;
  AlignmentIndicators? get alignmentIndicators =>
      throw _privateConstructorUsedError;

  /// Serializes this FunctioningOutput to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of FunctioningOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FunctioningOutputCopyWith<FunctioningOutput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FunctioningOutputCopyWith<$Res> {
  factory $FunctioningOutputCopyWith(
    FunctioningOutput value,
    $Res Function(FunctioningOutput) then,
  ) = _$FunctioningOutputCopyWithImpl<$Res, FunctioningOutput>;
  @useResult
  $Res call({
    List<String> coreTraits,
    String symbolicEssence,
    String narrativeArc,
    String redemptionArc,
    @CostsConverter() String? costsAndCompensations,
    String? powerStance,
    AlignmentIndicators? alignmentIndicators,
  });

  $AlignmentIndicatorsCopyWith<$Res>? get alignmentIndicators;
}

/// @nodoc
class _$FunctioningOutputCopyWithImpl<$Res, $Val extends FunctioningOutput>
    implements $FunctioningOutputCopyWith<$Res> {
  _$FunctioningOutputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FunctioningOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coreTraits = null,
    Object? symbolicEssence = null,
    Object? narrativeArc = null,
    Object? redemptionArc = null,
    Object? costsAndCompensations = freezed,
    Object? powerStance = freezed,
    Object? alignmentIndicators = freezed,
  }) {
    return _then(
      _value.copyWith(
            coreTraits: null == coreTraits
                ? _value.coreTraits
                : coreTraits // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            symbolicEssence: null == symbolicEssence
                ? _value.symbolicEssence
                : symbolicEssence // ignore: cast_nullable_to_non_nullable
                      as String,
            narrativeArc: null == narrativeArc
                ? _value.narrativeArc
                : narrativeArc // ignore: cast_nullable_to_non_nullable
                      as String,
            redemptionArc: null == redemptionArc
                ? _value.redemptionArc
                : redemptionArc // ignore: cast_nullable_to_non_nullable
                      as String,
            costsAndCompensations: freezed == costsAndCompensations
                ? _value.costsAndCompensations
                : costsAndCompensations // ignore: cast_nullable_to_non_nullable
                      as String?,
            powerStance: freezed == powerStance
                ? _value.powerStance
                : powerStance // ignore: cast_nullable_to_non_nullable
                      as String?,
            alignmentIndicators: freezed == alignmentIndicators
                ? _value.alignmentIndicators
                : alignmentIndicators // ignore: cast_nullable_to_non_nullable
                      as AlignmentIndicators?,
          )
          as $Val,
    );
  }

  /// Create a copy of FunctioningOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AlignmentIndicatorsCopyWith<$Res>? get alignmentIndicators {
    if (_value.alignmentIndicators == null) {
      return null;
    }

    return $AlignmentIndicatorsCopyWith<$Res>(_value.alignmentIndicators!, (
      value,
    ) {
      return _then(_value.copyWith(alignmentIndicators: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FunctioningOutputImplCopyWith<$Res>
    implements $FunctioningOutputCopyWith<$Res> {
  factory _$$FunctioningOutputImplCopyWith(
    _$FunctioningOutputImpl value,
    $Res Function(_$FunctioningOutputImpl) then,
  ) = __$$FunctioningOutputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    List<String> coreTraits,
    String symbolicEssence,
    String narrativeArc,
    String redemptionArc,
    @CostsConverter() String? costsAndCompensations,
    String? powerStance,
    AlignmentIndicators? alignmentIndicators,
  });

  @override
  $AlignmentIndicatorsCopyWith<$Res>? get alignmentIndicators;
}

/// @nodoc
class __$$FunctioningOutputImplCopyWithImpl<$Res>
    extends _$FunctioningOutputCopyWithImpl<$Res, _$FunctioningOutputImpl>
    implements _$$FunctioningOutputImplCopyWith<$Res> {
  __$$FunctioningOutputImplCopyWithImpl(
    _$FunctioningOutputImpl _value,
    $Res Function(_$FunctioningOutputImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of FunctioningOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coreTraits = null,
    Object? symbolicEssence = null,
    Object? narrativeArc = null,
    Object? redemptionArc = null,
    Object? costsAndCompensations = freezed,
    Object? powerStance = freezed,
    Object? alignmentIndicators = freezed,
  }) {
    return _then(
      _$FunctioningOutputImpl(
        coreTraits: null == coreTraits
            ? _value._coreTraits
            : coreTraits // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        symbolicEssence: null == symbolicEssence
            ? _value.symbolicEssence
            : symbolicEssence // ignore: cast_nullable_to_non_nullable
                  as String,
        narrativeArc: null == narrativeArc
            ? _value.narrativeArc
            : narrativeArc // ignore: cast_nullable_to_non_nullable
                  as String,
        redemptionArc: null == redemptionArc
            ? _value.redemptionArc
            : redemptionArc // ignore: cast_nullable_to_non_nullable
                  as String,
        costsAndCompensations: freezed == costsAndCompensations
            ? _value.costsAndCompensations
            : costsAndCompensations // ignore: cast_nullable_to_non_nullable
                  as String?,
        powerStance: freezed == powerStance
            ? _value.powerStance
            : powerStance // ignore: cast_nullable_to_non_nullable
                  as String?,
        alignmentIndicators: freezed == alignmentIndicators
            ? _value.alignmentIndicators
            : alignmentIndicators // ignore: cast_nullable_to_non_nullable
                  as AlignmentIndicators?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$FunctioningOutputImpl implements _FunctioningOutput {
  const _$FunctioningOutputImpl({
    required final List<String> coreTraits,
    required this.symbolicEssence,
    required this.narrativeArc,
    required this.redemptionArc,
    @CostsConverter() this.costsAndCompensations,
    this.powerStance,
    this.alignmentIndicators,
  }) : _coreTraits = coreTraits;

  factory _$FunctioningOutputImpl.fromJson(Map<String, dynamic> json) =>
      _$$FunctioningOutputImplFromJson(json);

  final List<String> _coreTraits;
  @override
  List<String> get coreTraits {
    if (_coreTraits is EqualUnmodifiableListView) return _coreTraits;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_coreTraits);
  }

  @override
  final String symbolicEssence;
  @override
  final String narrativeArc;
  @override
  final String redemptionArc;
  @override
  @CostsConverter()
  final String? costsAndCompensations;
  @override
  final String? powerStance;
  @override
  final AlignmentIndicators? alignmentIndicators;

  @override
  String toString() {
    return 'FunctioningOutput(coreTraits: $coreTraits, symbolicEssence: $symbolicEssence, narrativeArc: $narrativeArc, redemptionArc: $redemptionArc, costsAndCompensations: $costsAndCompensations, powerStance: $powerStance, alignmentIndicators: $alignmentIndicators)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FunctioningOutputImpl &&
            const DeepCollectionEquality().equals(
              other._coreTraits,
              _coreTraits,
            ) &&
            (identical(other.symbolicEssence, symbolicEssence) ||
                other.symbolicEssence == symbolicEssence) &&
            (identical(other.narrativeArc, narrativeArc) ||
                other.narrativeArc == narrativeArc) &&
            (identical(other.redemptionArc, redemptionArc) ||
                other.redemptionArc == redemptionArc) &&
            (identical(other.costsAndCompensations, costsAndCompensations) ||
                other.costsAndCompensations == costsAndCompensations) &&
            (identical(other.powerStance, powerStance) ||
                other.powerStance == powerStance) &&
            (identical(other.alignmentIndicators, alignmentIndicators) ||
                other.alignmentIndicators == alignmentIndicators));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    const DeepCollectionEquality().hash(_coreTraits),
    symbolicEssence,
    narrativeArc,
    redemptionArc,
    costsAndCompensations,
    powerStance,
    alignmentIndicators,
  );

  /// Create a copy of FunctioningOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FunctioningOutputImplCopyWith<_$FunctioningOutputImpl> get copyWith =>
      __$$FunctioningOutputImplCopyWithImpl<_$FunctioningOutputImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$FunctioningOutputImplToJson(this);
  }
}

abstract class _FunctioningOutput implements FunctioningOutput {
  const factory _FunctioningOutput({
    required final List<String> coreTraits,
    required final String symbolicEssence,
    required final String narrativeArc,
    required final String redemptionArc,
    @CostsConverter() final String? costsAndCompensations,
    final String? powerStance,
    final AlignmentIndicators? alignmentIndicators,
  }) = _$FunctioningOutputImpl;

  factory _FunctioningOutput.fromJson(Map<String, dynamic> json) =
      _$FunctioningOutputImpl.fromJson;

  @override
  List<String> get coreTraits;
  @override
  String get symbolicEssence;
  @override
  String get narrativeArc;
  @override
  String get redemptionArc;
  @override
  @CostsConverter()
  String? get costsAndCompensations;
  @override
  String? get powerStance;
  @override
  AlignmentIndicators? get alignmentIndicators;

  /// Create a copy of FunctioningOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FunctioningOutputImplCopyWith<_$FunctioningOutputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ActionsOutput _$ActionsOutputFromJson(Map<String, dynamic> json) {
  return _ActionsOutput.fromJson(json);
}

/// @nodoc
mixin _$ActionsOutput {
  List<SituationBlock> get situationBlocks =>
      throw _privateConstructorUsedError;
  String get guidingQuestion => throw _privateConstructorUsedError;

  /// Serializes this ActionsOutput to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ActionsOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ActionsOutputCopyWith<ActionsOutput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ActionsOutputCopyWith<$Res> {
  factory $ActionsOutputCopyWith(
    ActionsOutput value,
    $Res Function(ActionsOutput) then,
  ) = _$ActionsOutputCopyWithImpl<$Res, ActionsOutput>;
  @useResult
  $Res call({List<SituationBlock> situationBlocks, String guidingQuestion});
}

/// @nodoc
class _$ActionsOutputCopyWithImpl<$Res, $Val extends ActionsOutput>
    implements $ActionsOutputCopyWith<$Res> {
  _$ActionsOutputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ActionsOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? situationBlocks = null, Object? guidingQuestion = null}) {
    return _then(
      _value.copyWith(
            situationBlocks: null == situationBlocks
                ? _value.situationBlocks
                : situationBlocks // ignore: cast_nullable_to_non_nullable
                      as List<SituationBlock>,
            guidingQuestion: null == guidingQuestion
                ? _value.guidingQuestion
                : guidingQuestion // ignore: cast_nullable_to_non_nullable
                      as String,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$ActionsOutputImplCopyWith<$Res>
    implements $ActionsOutputCopyWith<$Res> {
  factory _$$ActionsOutputImplCopyWith(
    _$ActionsOutputImpl value,
    $Res Function(_$ActionsOutputImpl) then,
  ) = __$$ActionsOutputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<SituationBlock> situationBlocks, String guidingQuestion});
}

/// @nodoc
class __$$ActionsOutputImplCopyWithImpl<$Res>
    extends _$ActionsOutputCopyWithImpl<$Res, _$ActionsOutputImpl>
    implements _$$ActionsOutputImplCopyWith<$Res> {
  __$$ActionsOutputImplCopyWithImpl(
    _$ActionsOutputImpl _value,
    $Res Function(_$ActionsOutputImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ActionsOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? situationBlocks = null, Object? guidingQuestion = null}) {
    return _then(
      _$ActionsOutputImpl(
        situationBlocks: null == situationBlocks
            ? _value._situationBlocks
            : situationBlocks // ignore: cast_nullable_to_non_nullable
                  as List<SituationBlock>,
        guidingQuestion: null == guidingQuestion
            ? _value.guidingQuestion
            : guidingQuestion // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ActionsOutputImpl implements _ActionsOutput {
  const _$ActionsOutputImpl({
    required final List<SituationBlock> situationBlocks,
    required this.guidingQuestion,
  }) : _situationBlocks = situationBlocks;

  factory _$ActionsOutputImpl.fromJson(Map<String, dynamic> json) =>
      _$$ActionsOutputImplFromJson(json);

  final List<SituationBlock> _situationBlocks;
  @override
  List<SituationBlock> get situationBlocks {
    if (_situationBlocks is EqualUnmodifiableListView) return _situationBlocks;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_situationBlocks);
  }

  @override
  final String guidingQuestion;

  @override
  String toString() {
    return 'ActionsOutput(situationBlocks: $situationBlocks, guidingQuestion: $guidingQuestion)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ActionsOutputImpl &&
            const DeepCollectionEquality().equals(
              other._situationBlocks,
              _situationBlocks,
            ) &&
            (identical(other.guidingQuestion, guidingQuestion) ||
                other.guidingQuestion == guidingQuestion));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    const DeepCollectionEquality().hash(_situationBlocks),
    guidingQuestion,
  );

  /// Create a copy of ActionsOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ActionsOutputImplCopyWith<_$ActionsOutputImpl> get copyWith =>
      __$$ActionsOutputImplCopyWithImpl<_$ActionsOutputImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ActionsOutputImplToJson(this);
  }
}

abstract class _ActionsOutput implements ActionsOutput {
  const factory _ActionsOutput({
    required final List<SituationBlock> situationBlocks,
    required final String guidingQuestion,
  }) = _$ActionsOutputImpl;

  factory _ActionsOutput.fromJson(Map<String, dynamic> json) =
      _$ActionsOutputImpl.fromJson;

  @override
  List<SituationBlock> get situationBlocks;
  @override
  String get guidingQuestion;

  /// Create a copy of ActionsOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ActionsOutputImplCopyWith<_$ActionsOutputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

LifeDomainsOutput _$LifeDomainsOutputFromJson(Map<String, dynamic> json) {
  return _LifeDomainsOutput.fromJson(json);
}

/// @nodoc
mixin _$LifeDomainsOutput {
  DomainBlock get work => throw _privateConstructorUsedError;
  DomainBlock get leadership => throw _privateConstructorUsedError;
  DomainBlock get truth => throw _privateConstructorUsedError;
  DomainBlock get intimacy => throw _privateConstructorUsedError;
  DomainBlock get social => throw _privateConstructorUsedError;
  DomainBlock get innerLife => throw _privateConstructorUsedError;

  /// Serializes this LifeDomainsOutput to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of LifeDomainsOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LifeDomainsOutputCopyWith<LifeDomainsOutput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LifeDomainsOutputCopyWith<$Res> {
  factory $LifeDomainsOutputCopyWith(
    LifeDomainsOutput value,
    $Res Function(LifeDomainsOutput) then,
  ) = _$LifeDomainsOutputCopyWithImpl<$Res, LifeDomainsOutput>;
  @useResult
  $Res call({
    DomainBlock work,
    DomainBlock leadership,
    DomainBlock truth,
    DomainBlock intimacy,
    DomainBlock social,
    DomainBlock innerLife,
  });

  $DomainBlockCopyWith<$Res> get work;
  $DomainBlockCopyWith<$Res> get leadership;
  $DomainBlockCopyWith<$Res> get truth;
  $DomainBlockCopyWith<$Res> get intimacy;
  $DomainBlockCopyWith<$Res> get social;
  $DomainBlockCopyWith<$Res> get innerLife;
}

/// @nodoc
class _$LifeDomainsOutputCopyWithImpl<$Res, $Val extends LifeDomainsOutput>
    implements $LifeDomainsOutputCopyWith<$Res> {
  _$LifeDomainsOutputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LifeDomainsOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? work = null,
    Object? leadership = null,
    Object? truth = null,
    Object? intimacy = null,
    Object? social = null,
    Object? innerLife = null,
  }) {
    return _then(
      _value.copyWith(
            work: null == work
                ? _value.work
                : work // ignore: cast_nullable_to_non_nullable
                      as DomainBlock,
            leadership: null == leadership
                ? _value.leadership
                : leadership // ignore: cast_nullable_to_non_nullable
                      as DomainBlock,
            truth: null == truth
                ? _value.truth
                : truth // ignore: cast_nullable_to_non_nullable
                      as DomainBlock,
            intimacy: null == intimacy
                ? _value.intimacy
                : intimacy // ignore: cast_nullable_to_non_nullable
                      as DomainBlock,
            social: null == social
                ? _value.social
                : social // ignore: cast_nullable_to_non_nullable
                      as DomainBlock,
            innerLife: null == innerLife
                ? _value.innerLife
                : innerLife // ignore: cast_nullable_to_non_nullable
                      as DomainBlock,
          )
          as $Val,
    );
  }

  /// Create a copy of LifeDomainsOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DomainBlockCopyWith<$Res> get work {
    return $DomainBlockCopyWith<$Res>(_value.work, (value) {
      return _then(_value.copyWith(work: value) as $Val);
    });
  }

  /// Create a copy of LifeDomainsOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DomainBlockCopyWith<$Res> get leadership {
    return $DomainBlockCopyWith<$Res>(_value.leadership, (value) {
      return _then(_value.copyWith(leadership: value) as $Val);
    });
  }

  /// Create a copy of LifeDomainsOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DomainBlockCopyWith<$Res> get truth {
    return $DomainBlockCopyWith<$Res>(_value.truth, (value) {
      return _then(_value.copyWith(truth: value) as $Val);
    });
  }

  /// Create a copy of LifeDomainsOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DomainBlockCopyWith<$Res> get intimacy {
    return $DomainBlockCopyWith<$Res>(_value.intimacy, (value) {
      return _then(_value.copyWith(intimacy: value) as $Val);
    });
  }

  /// Create a copy of LifeDomainsOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DomainBlockCopyWith<$Res> get social {
    return $DomainBlockCopyWith<$Res>(_value.social, (value) {
      return _then(_value.copyWith(social: value) as $Val);
    });
  }

  /// Create a copy of LifeDomainsOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DomainBlockCopyWith<$Res> get innerLife {
    return $DomainBlockCopyWith<$Res>(_value.innerLife, (value) {
      return _then(_value.copyWith(innerLife: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$LifeDomainsOutputImplCopyWith<$Res>
    implements $LifeDomainsOutputCopyWith<$Res> {
  factory _$$LifeDomainsOutputImplCopyWith(
    _$LifeDomainsOutputImpl value,
    $Res Function(_$LifeDomainsOutputImpl) then,
  ) = __$$LifeDomainsOutputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    DomainBlock work,
    DomainBlock leadership,
    DomainBlock truth,
    DomainBlock intimacy,
    DomainBlock social,
    DomainBlock innerLife,
  });

  @override
  $DomainBlockCopyWith<$Res> get work;
  @override
  $DomainBlockCopyWith<$Res> get leadership;
  @override
  $DomainBlockCopyWith<$Res> get truth;
  @override
  $DomainBlockCopyWith<$Res> get intimacy;
  @override
  $DomainBlockCopyWith<$Res> get social;
  @override
  $DomainBlockCopyWith<$Res> get innerLife;
}

/// @nodoc
class __$$LifeDomainsOutputImplCopyWithImpl<$Res>
    extends _$LifeDomainsOutputCopyWithImpl<$Res, _$LifeDomainsOutputImpl>
    implements _$$LifeDomainsOutputImplCopyWith<$Res> {
  __$$LifeDomainsOutputImplCopyWithImpl(
    _$LifeDomainsOutputImpl _value,
    $Res Function(_$LifeDomainsOutputImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of LifeDomainsOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? work = null,
    Object? leadership = null,
    Object? truth = null,
    Object? intimacy = null,
    Object? social = null,
    Object? innerLife = null,
  }) {
    return _then(
      _$LifeDomainsOutputImpl(
        work: null == work
            ? _value.work
            : work // ignore: cast_nullable_to_non_nullable
                  as DomainBlock,
        leadership: null == leadership
            ? _value.leadership
            : leadership // ignore: cast_nullable_to_non_nullable
                  as DomainBlock,
        truth: null == truth
            ? _value.truth
            : truth // ignore: cast_nullable_to_non_nullable
                  as DomainBlock,
        intimacy: null == intimacy
            ? _value.intimacy
            : intimacy // ignore: cast_nullable_to_non_nullable
                  as DomainBlock,
        social: null == social
            ? _value.social
            : social // ignore: cast_nullable_to_non_nullable
                  as DomainBlock,
        innerLife: null == innerLife
            ? _value.innerLife
            : innerLife // ignore: cast_nullable_to_non_nullable
                  as DomainBlock,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$LifeDomainsOutputImpl implements _LifeDomainsOutput {
  const _$LifeDomainsOutputImpl({
    required this.work,
    required this.leadership,
    required this.truth,
    required this.intimacy,
    required this.social,
    required this.innerLife,
  });

  factory _$LifeDomainsOutputImpl.fromJson(Map<String, dynamic> json) =>
      _$$LifeDomainsOutputImplFromJson(json);

  @override
  final DomainBlock work;
  @override
  final DomainBlock leadership;
  @override
  final DomainBlock truth;
  @override
  final DomainBlock intimacy;
  @override
  final DomainBlock social;
  @override
  final DomainBlock innerLife;

  @override
  String toString() {
    return 'LifeDomainsOutput(work: $work, leadership: $leadership, truth: $truth, intimacy: $intimacy, social: $social, innerLife: $innerLife)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LifeDomainsOutputImpl &&
            (identical(other.work, work) || other.work == work) &&
            (identical(other.leadership, leadership) ||
                other.leadership == leadership) &&
            (identical(other.truth, truth) || other.truth == truth) &&
            (identical(other.intimacy, intimacy) ||
                other.intimacy == intimacy) &&
            (identical(other.social, social) || other.social == social) &&
            (identical(other.innerLife, innerLife) ||
                other.innerLife == innerLife));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    work,
    leadership,
    truth,
    intimacy,
    social,
    innerLife,
  );

  /// Create a copy of LifeDomainsOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LifeDomainsOutputImplCopyWith<_$LifeDomainsOutputImpl> get copyWith =>
      __$$LifeDomainsOutputImplCopyWithImpl<_$LifeDomainsOutputImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$LifeDomainsOutputImplToJson(this);
  }
}

abstract class _LifeDomainsOutput implements LifeDomainsOutput {
  const factory _LifeDomainsOutput({
    required final DomainBlock work,
    required final DomainBlock leadership,
    required final DomainBlock truth,
    required final DomainBlock intimacy,
    required final DomainBlock social,
    required final DomainBlock innerLife,
  }) = _$LifeDomainsOutputImpl;

  factory _LifeDomainsOutput.fromJson(Map<String, dynamic> json) =
      _$LifeDomainsOutputImpl.fromJson;

  @override
  DomainBlock get work;
  @override
  DomainBlock get leadership;
  @override
  DomainBlock get truth;
  @override
  DomainBlock get intimacy;
  @override
  DomainBlock get social;
  @override
  DomainBlock get innerLife;

  /// Create a copy of LifeDomainsOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LifeDomainsOutputImplCopyWith<_$LifeDomainsOutputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ArchetypeBlock _$ArchetypeBlockFromJson(Map<String, dynamic> json) {
  return _ArchetypeBlock.fromJson(json);
}

/// @nodoc
mixin _$ArchetypeBlock {
  String get title => throw _privateConstructorUsedError;
  String get summary => throw _privateConstructorUsedError;
  List<String> get characters => throw _privateConstructorUsedError;
  String? get details => throw _privateConstructorUsedError;

  /// Serializes this ArchetypeBlock to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ArchetypeBlock
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ArchetypeBlockCopyWith<ArchetypeBlock> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ArchetypeBlockCopyWith<$Res> {
  factory $ArchetypeBlockCopyWith(
    ArchetypeBlock value,
    $Res Function(ArchetypeBlock) then,
  ) = _$ArchetypeBlockCopyWithImpl<$Res, ArchetypeBlock>;
  @useResult
  $Res call({
    String title,
    String summary,
    List<String> characters,
    String? details,
  });
}

/// @nodoc
class _$ArchetypeBlockCopyWithImpl<$Res, $Val extends ArchetypeBlock>
    implements $ArchetypeBlockCopyWith<$Res> {
  _$ArchetypeBlockCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ArchetypeBlock
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? summary = null,
    Object? characters = null,
    Object? details = freezed,
  }) {
    return _then(
      _value.copyWith(
            title: null == title
                ? _value.title
                : title // ignore: cast_nullable_to_non_nullable
                      as String,
            summary: null == summary
                ? _value.summary
                : summary // ignore: cast_nullable_to_non_nullable
                      as String,
            characters: null == characters
                ? _value.characters
                : characters // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            details: freezed == details
                ? _value.details
                : details // ignore: cast_nullable_to_non_nullable
                      as String?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$ArchetypeBlockImplCopyWith<$Res>
    implements $ArchetypeBlockCopyWith<$Res> {
  factory _$$ArchetypeBlockImplCopyWith(
    _$ArchetypeBlockImpl value,
    $Res Function(_$ArchetypeBlockImpl) then,
  ) = __$$ArchetypeBlockImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String title,
    String summary,
    List<String> characters,
    String? details,
  });
}

/// @nodoc
class __$$ArchetypeBlockImplCopyWithImpl<$Res>
    extends _$ArchetypeBlockCopyWithImpl<$Res, _$ArchetypeBlockImpl>
    implements _$$ArchetypeBlockImplCopyWith<$Res> {
  __$$ArchetypeBlockImplCopyWithImpl(
    _$ArchetypeBlockImpl _value,
    $Res Function(_$ArchetypeBlockImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ArchetypeBlock
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? summary = null,
    Object? characters = null,
    Object? details = freezed,
  }) {
    return _then(
      _$ArchetypeBlockImpl(
        title: null == title
            ? _value.title
            : title // ignore: cast_nullable_to_non_nullable
                  as String,
        summary: null == summary
            ? _value.summary
            : summary // ignore: cast_nullable_to_non_nullable
                  as String,
        characters: null == characters
            ? _value._characters
            : characters // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        details: freezed == details
            ? _value.details
            : details // ignore: cast_nullable_to_non_nullable
                  as String?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ArchetypeBlockImpl implements _ArchetypeBlock {
  const _$ArchetypeBlockImpl({
    required this.title,
    required this.summary,
    required final List<String> characters,
    this.details,
  }) : _characters = characters;

  factory _$ArchetypeBlockImpl.fromJson(Map<String, dynamic> json) =>
      _$$ArchetypeBlockImplFromJson(json);

  @override
  final String title;
  @override
  final String summary;
  final List<String> _characters;
  @override
  List<String> get characters {
    if (_characters is EqualUnmodifiableListView) return _characters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_characters);
  }

  @override
  final String? details;

  @override
  String toString() {
    return 'ArchetypeBlock(title: $title, summary: $summary, characters: $characters, details: $details)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ArchetypeBlockImpl &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.summary, summary) || other.summary == summary) &&
            const DeepCollectionEquality().equals(
              other._characters,
              _characters,
            ) &&
            (identical(other.details, details) || other.details == details));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    title,
    summary,
    const DeepCollectionEquality().hash(_characters),
    details,
  );

  /// Create a copy of ArchetypeBlock
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ArchetypeBlockImplCopyWith<_$ArchetypeBlockImpl> get copyWith =>
      __$$ArchetypeBlockImplCopyWithImpl<_$ArchetypeBlockImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$ArchetypeBlockImplToJson(this);
  }
}

abstract class _ArchetypeBlock implements ArchetypeBlock {
  const factory _ArchetypeBlock({
    required final String title,
    required final String summary,
    required final List<String> characters,
    final String? details,
  }) = _$ArchetypeBlockImpl;

  factory _ArchetypeBlock.fromJson(Map<String, dynamic> json) =
      _$ArchetypeBlockImpl.fromJson;

  @override
  String get title;
  @override
  String get summary;
  @override
  List<String> get characters;
  @override
  String? get details;

  /// Create a copy of ArchetypeBlock
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ArchetypeBlockImplCopyWith<_$ArchetypeBlockImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EvidenceItem _$EvidenceItemFromJson(Map<String, dynamic> json) {
  return _EvidenceItem.fromJson(json);
}

/// @nodoc
mixin _$EvidenceItem {
  String get targetPath => throw _privateConstructorUsedError;
  List<String> get characterRefs => throw _privateConstructorUsedError;
  List<String> get assessmentRefs => throw _privateConstructorUsedError;

  /// Serializes this EvidenceItem to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of EvidenceItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $EvidenceItemCopyWith<EvidenceItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EvidenceItemCopyWith<$Res> {
  factory $EvidenceItemCopyWith(
    EvidenceItem value,
    $Res Function(EvidenceItem) then,
  ) = _$EvidenceItemCopyWithImpl<$Res, EvidenceItem>;
  @useResult
  $Res call({
    String targetPath,
    List<String> characterRefs,
    List<String> assessmentRefs,
  });
}

/// @nodoc
class _$EvidenceItemCopyWithImpl<$Res, $Val extends EvidenceItem>
    implements $EvidenceItemCopyWith<$Res> {
  _$EvidenceItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EvidenceItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? targetPath = null,
    Object? characterRefs = null,
    Object? assessmentRefs = null,
  }) {
    return _then(
      _value.copyWith(
            targetPath: null == targetPath
                ? _value.targetPath
                : targetPath // ignore: cast_nullable_to_non_nullable
                      as String,
            characterRefs: null == characterRefs
                ? _value.characterRefs
                : characterRefs // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            assessmentRefs: null == assessmentRefs
                ? _value.assessmentRefs
                : assessmentRefs // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$EvidenceItemImplCopyWith<$Res>
    implements $EvidenceItemCopyWith<$Res> {
  factory _$$EvidenceItemImplCopyWith(
    _$EvidenceItemImpl value,
    $Res Function(_$EvidenceItemImpl) then,
  ) = __$$EvidenceItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String targetPath,
    List<String> characterRefs,
    List<String> assessmentRefs,
  });
}

/// @nodoc
class __$$EvidenceItemImplCopyWithImpl<$Res>
    extends _$EvidenceItemCopyWithImpl<$Res, _$EvidenceItemImpl>
    implements _$$EvidenceItemImplCopyWith<$Res> {
  __$$EvidenceItemImplCopyWithImpl(
    _$EvidenceItemImpl _value,
    $Res Function(_$EvidenceItemImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of EvidenceItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? targetPath = null,
    Object? characterRefs = null,
    Object? assessmentRefs = null,
  }) {
    return _then(
      _$EvidenceItemImpl(
        targetPath: null == targetPath
            ? _value.targetPath
            : targetPath // ignore: cast_nullable_to_non_nullable
                  as String,
        characterRefs: null == characterRefs
            ? _value._characterRefs
            : characterRefs // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        assessmentRefs: null == assessmentRefs
            ? _value._assessmentRefs
            : assessmentRefs // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$EvidenceItemImpl implements _EvidenceItem {
  const _$EvidenceItemImpl({
    required this.targetPath,
    required final List<String> characterRefs,
    required final List<String> assessmentRefs,
  }) : _characterRefs = characterRefs,
       _assessmentRefs = assessmentRefs;

  factory _$EvidenceItemImpl.fromJson(Map<String, dynamic> json) =>
      _$$EvidenceItemImplFromJson(json);

  @override
  final String targetPath;
  final List<String> _characterRefs;
  @override
  List<String> get characterRefs {
    if (_characterRefs is EqualUnmodifiableListView) return _characterRefs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_characterRefs);
  }

  final List<String> _assessmentRefs;
  @override
  List<String> get assessmentRefs {
    if (_assessmentRefs is EqualUnmodifiableListView) return _assessmentRefs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_assessmentRefs);
  }

  @override
  String toString() {
    return 'EvidenceItem(targetPath: $targetPath, characterRefs: $characterRefs, assessmentRefs: $assessmentRefs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EvidenceItemImpl &&
            (identical(other.targetPath, targetPath) ||
                other.targetPath == targetPath) &&
            const DeepCollectionEquality().equals(
              other._characterRefs,
              _characterRefs,
            ) &&
            const DeepCollectionEquality().equals(
              other._assessmentRefs,
              _assessmentRefs,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    targetPath,
    const DeepCollectionEquality().hash(_characterRefs),
    const DeepCollectionEquality().hash(_assessmentRefs),
  );

  /// Create a copy of EvidenceItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EvidenceItemImplCopyWith<_$EvidenceItemImpl> get copyWith =>
      __$$EvidenceItemImplCopyWithImpl<_$EvidenceItemImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EvidenceItemImplToJson(this);
  }
}

abstract class _EvidenceItem implements EvidenceItem {
  const factory _EvidenceItem({
    required final String targetPath,
    required final List<String> characterRefs,
    required final List<String> assessmentRefs,
  }) = _$EvidenceItemImpl;

  factory _EvidenceItem.fromJson(Map<String, dynamic> json) =
      _$EvidenceItemImpl.fromJson;

  @override
  String get targetPath;
  @override
  List<String> get characterRefs;
  @override
  List<String> get assessmentRefs;

  /// Create a copy of EvidenceItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EvidenceItemImplCopyWith<_$EvidenceItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

SituationBlock _$SituationBlockFromJson(Map<String, dynamic> json) {
  return _SituationBlock.fromJson(json);
}

/// @nodoc
mixin _$SituationBlock {
  String? get title => throw _privateConstructorUsedError;
  String get situation => throw _privateConstructorUsedError;
  List<String> get alignedResponse => throw _privateConstructorUsedError;
  List<String> get beWaryOf => throw _privateConstructorUsedError;

  /// Serializes this SituationBlock to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SituationBlock
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SituationBlockCopyWith<SituationBlock> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SituationBlockCopyWith<$Res> {
  factory $SituationBlockCopyWith(
    SituationBlock value,
    $Res Function(SituationBlock) then,
  ) = _$SituationBlockCopyWithImpl<$Res, SituationBlock>;
  @useResult
  $Res call({
    String? title,
    String situation,
    List<String> alignedResponse,
    List<String> beWaryOf,
  });
}

/// @nodoc
class _$SituationBlockCopyWithImpl<$Res, $Val extends SituationBlock>
    implements $SituationBlockCopyWith<$Res> {
  _$SituationBlockCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SituationBlock
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = freezed,
    Object? situation = null,
    Object? alignedResponse = null,
    Object? beWaryOf = null,
  }) {
    return _then(
      _value.copyWith(
            title: freezed == title
                ? _value.title
                : title // ignore: cast_nullable_to_non_nullable
                      as String?,
            situation: null == situation
                ? _value.situation
                : situation // ignore: cast_nullable_to_non_nullable
                      as String,
            alignedResponse: null == alignedResponse
                ? _value.alignedResponse
                : alignedResponse // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            beWaryOf: null == beWaryOf
                ? _value.beWaryOf
                : beWaryOf // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$SituationBlockImplCopyWith<$Res>
    implements $SituationBlockCopyWith<$Res> {
  factory _$$SituationBlockImplCopyWith(
    _$SituationBlockImpl value,
    $Res Function(_$SituationBlockImpl) then,
  ) = __$$SituationBlockImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String? title,
    String situation,
    List<String> alignedResponse,
    List<String> beWaryOf,
  });
}

/// @nodoc
class __$$SituationBlockImplCopyWithImpl<$Res>
    extends _$SituationBlockCopyWithImpl<$Res, _$SituationBlockImpl>
    implements _$$SituationBlockImplCopyWith<$Res> {
  __$$SituationBlockImplCopyWithImpl(
    _$SituationBlockImpl _value,
    $Res Function(_$SituationBlockImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SituationBlock
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = freezed,
    Object? situation = null,
    Object? alignedResponse = null,
    Object? beWaryOf = null,
  }) {
    return _then(
      _$SituationBlockImpl(
        title: freezed == title
            ? _value.title
            : title // ignore: cast_nullable_to_non_nullable
                  as String?,
        situation: null == situation
            ? _value.situation
            : situation // ignore: cast_nullable_to_non_nullable
                  as String,
        alignedResponse: null == alignedResponse
            ? _value._alignedResponse
            : alignedResponse // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        beWaryOf: null == beWaryOf
            ? _value._beWaryOf
            : beWaryOf // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$SituationBlockImpl implements _SituationBlock {
  const _$SituationBlockImpl({
    this.title,
    required this.situation,
    required final List<String> alignedResponse,
    required final List<String> beWaryOf,
  }) : _alignedResponse = alignedResponse,
       _beWaryOf = beWaryOf;

  factory _$SituationBlockImpl.fromJson(Map<String, dynamic> json) =>
      _$$SituationBlockImplFromJson(json);

  @override
  final String? title;
  @override
  final String situation;
  final List<String> _alignedResponse;
  @override
  List<String> get alignedResponse {
    if (_alignedResponse is EqualUnmodifiableListView) return _alignedResponse;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_alignedResponse);
  }

  final List<String> _beWaryOf;
  @override
  List<String> get beWaryOf {
    if (_beWaryOf is EqualUnmodifiableListView) return _beWaryOf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_beWaryOf);
  }

  @override
  String toString() {
    return 'SituationBlock(title: $title, situation: $situation, alignedResponse: $alignedResponse, beWaryOf: $beWaryOf)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SituationBlockImpl &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.situation, situation) ||
                other.situation == situation) &&
            const DeepCollectionEquality().equals(
              other._alignedResponse,
              _alignedResponse,
            ) &&
            const DeepCollectionEquality().equals(other._beWaryOf, _beWaryOf));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    title,
    situation,
    const DeepCollectionEquality().hash(_alignedResponse),
    const DeepCollectionEquality().hash(_beWaryOf),
  );

  /// Create a copy of SituationBlock
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SituationBlockImplCopyWith<_$SituationBlockImpl> get copyWith =>
      __$$SituationBlockImplCopyWithImpl<_$SituationBlockImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$SituationBlockImplToJson(this);
  }
}

abstract class _SituationBlock implements SituationBlock {
  const factory _SituationBlock({
    final String? title,
    required final String situation,
    required final List<String> alignedResponse,
    required final List<String> beWaryOf,
  }) = _$SituationBlockImpl;

  factory _SituationBlock.fromJson(Map<String, dynamic> json) =
      _$SituationBlockImpl.fromJson;

  @override
  String? get title;
  @override
  String get situation;
  @override
  List<String> get alignedResponse;
  @override
  List<String> get beWaryOf;

  /// Create a copy of SituationBlock
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SituationBlockImplCopyWith<_$SituationBlockImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DomainBlock _$DomainBlockFromJson(Map<String, dynamic> json) {
  return _DomainBlock.fromJson(json);
}

/// @nodoc
mixin _$DomainBlock {
  String get title => throw _privateConstructorUsedError;
  @StringOrListConverter()
  List<String> get iAm => throw _privateConstructorUsedError;
  @StringOrListConverter()
  List<String> get iTendTo => throw _privateConstructorUsedError;
  @StringOrListConverter()
  List<String> get typicalSituations => throw _privateConstructorUsedError;
  @StringOrListConverter()
  List<String> get watchOuts => throw _privateConstructorUsedError;
  @StringOrListConverter()
  List<String> get toRealizePotential => throw _privateConstructorUsedError;
  String get selfDirection => throw _privateConstructorUsedError;

  /// Serializes this DomainBlock to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of DomainBlock
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DomainBlockCopyWith<DomainBlock> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DomainBlockCopyWith<$Res> {
  factory $DomainBlockCopyWith(
    DomainBlock value,
    $Res Function(DomainBlock) then,
  ) = _$DomainBlockCopyWithImpl<$Res, DomainBlock>;
  @useResult
  $Res call({
    String title,
    @StringOrListConverter() List<String> iAm,
    @StringOrListConverter() List<String> iTendTo,
    @StringOrListConverter() List<String> typicalSituations,
    @StringOrListConverter() List<String> watchOuts,
    @StringOrListConverter() List<String> toRealizePotential,
    String selfDirection,
  });
}

/// @nodoc
class _$DomainBlockCopyWithImpl<$Res, $Val extends DomainBlock>
    implements $DomainBlockCopyWith<$Res> {
  _$DomainBlockCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DomainBlock
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? iAm = null,
    Object? iTendTo = null,
    Object? typicalSituations = null,
    Object? watchOuts = null,
    Object? toRealizePotential = null,
    Object? selfDirection = null,
  }) {
    return _then(
      _value.copyWith(
            title: null == title
                ? _value.title
                : title // ignore: cast_nullable_to_non_nullable
                      as String,
            iAm: null == iAm
                ? _value.iAm
                : iAm // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            iTendTo: null == iTendTo
                ? _value.iTendTo
                : iTendTo // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            typicalSituations: null == typicalSituations
                ? _value.typicalSituations
                : typicalSituations // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            watchOuts: null == watchOuts
                ? _value.watchOuts
                : watchOuts // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            toRealizePotential: null == toRealizePotential
                ? _value.toRealizePotential
                : toRealizePotential // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            selfDirection: null == selfDirection
                ? _value.selfDirection
                : selfDirection // ignore: cast_nullable_to_non_nullable
                      as String,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$DomainBlockImplCopyWith<$Res>
    implements $DomainBlockCopyWith<$Res> {
  factory _$$DomainBlockImplCopyWith(
    _$DomainBlockImpl value,
    $Res Function(_$DomainBlockImpl) then,
  ) = __$$DomainBlockImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String title,
    @StringOrListConverter() List<String> iAm,
    @StringOrListConverter() List<String> iTendTo,
    @StringOrListConverter() List<String> typicalSituations,
    @StringOrListConverter() List<String> watchOuts,
    @StringOrListConverter() List<String> toRealizePotential,
    String selfDirection,
  });
}

/// @nodoc
class __$$DomainBlockImplCopyWithImpl<$Res>
    extends _$DomainBlockCopyWithImpl<$Res, _$DomainBlockImpl>
    implements _$$DomainBlockImplCopyWith<$Res> {
  __$$DomainBlockImplCopyWithImpl(
    _$DomainBlockImpl _value,
    $Res Function(_$DomainBlockImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DomainBlock
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? iAm = null,
    Object? iTendTo = null,
    Object? typicalSituations = null,
    Object? watchOuts = null,
    Object? toRealizePotential = null,
    Object? selfDirection = null,
  }) {
    return _then(
      _$DomainBlockImpl(
        title: null == title
            ? _value.title
            : title // ignore: cast_nullable_to_non_nullable
                  as String,
        iAm: null == iAm
            ? _value._iAm
            : iAm // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        iTendTo: null == iTendTo
            ? _value._iTendTo
            : iTendTo // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        typicalSituations: null == typicalSituations
            ? _value._typicalSituations
            : typicalSituations // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        watchOuts: null == watchOuts
            ? _value._watchOuts
            : watchOuts // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        toRealizePotential: null == toRealizePotential
            ? _value._toRealizePotential
            : toRealizePotential // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        selfDirection: null == selfDirection
            ? _value.selfDirection
            : selfDirection // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$DomainBlockImpl implements _DomainBlock {
  const _$DomainBlockImpl({
    required this.title,
    @StringOrListConverter() required final List<String> iAm,
    @StringOrListConverter() required final List<String> iTendTo,
    @StringOrListConverter() required final List<String> typicalSituations,
    @StringOrListConverter() required final List<String> watchOuts,
    @StringOrListConverter() required final List<String> toRealizePotential,
    required this.selfDirection,
  }) : _iAm = iAm,
       _iTendTo = iTendTo,
       _typicalSituations = typicalSituations,
       _watchOuts = watchOuts,
       _toRealizePotential = toRealizePotential;

  factory _$DomainBlockImpl.fromJson(Map<String, dynamic> json) =>
      _$$DomainBlockImplFromJson(json);

  @override
  final String title;
  final List<String> _iAm;
  @override
  @StringOrListConverter()
  List<String> get iAm {
    if (_iAm is EqualUnmodifiableListView) return _iAm;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_iAm);
  }

  final List<String> _iTendTo;
  @override
  @StringOrListConverter()
  List<String> get iTendTo {
    if (_iTendTo is EqualUnmodifiableListView) return _iTendTo;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_iTendTo);
  }

  final List<String> _typicalSituations;
  @override
  @StringOrListConverter()
  List<String> get typicalSituations {
    if (_typicalSituations is EqualUnmodifiableListView)
      return _typicalSituations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_typicalSituations);
  }

  final List<String> _watchOuts;
  @override
  @StringOrListConverter()
  List<String> get watchOuts {
    if (_watchOuts is EqualUnmodifiableListView) return _watchOuts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_watchOuts);
  }

  final List<String> _toRealizePotential;
  @override
  @StringOrListConverter()
  List<String> get toRealizePotential {
    if (_toRealizePotential is EqualUnmodifiableListView)
      return _toRealizePotential;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_toRealizePotential);
  }

  @override
  final String selfDirection;

  @override
  String toString() {
    return 'DomainBlock(title: $title, iAm: $iAm, iTendTo: $iTendTo, typicalSituations: $typicalSituations, watchOuts: $watchOuts, toRealizePotential: $toRealizePotential, selfDirection: $selfDirection)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DomainBlockImpl &&
            (identical(other.title, title) || other.title == title) &&
            const DeepCollectionEquality().equals(other._iAm, _iAm) &&
            const DeepCollectionEquality().equals(other._iTendTo, _iTendTo) &&
            const DeepCollectionEquality().equals(
              other._typicalSituations,
              _typicalSituations,
            ) &&
            const DeepCollectionEquality().equals(
              other._watchOuts,
              _watchOuts,
            ) &&
            const DeepCollectionEquality().equals(
              other._toRealizePotential,
              _toRealizePotential,
            ) &&
            (identical(other.selfDirection, selfDirection) ||
                other.selfDirection == selfDirection));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    title,
    const DeepCollectionEquality().hash(_iAm),
    const DeepCollectionEquality().hash(_iTendTo),
    const DeepCollectionEquality().hash(_typicalSituations),
    const DeepCollectionEquality().hash(_watchOuts),
    const DeepCollectionEquality().hash(_toRealizePotential),
    selfDirection,
  );

  /// Create a copy of DomainBlock
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DomainBlockImplCopyWith<_$DomainBlockImpl> get copyWith =>
      __$$DomainBlockImplCopyWithImpl<_$DomainBlockImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DomainBlockImplToJson(this);
  }
}

abstract class _DomainBlock implements DomainBlock {
  const factory _DomainBlock({
    required final String title,
    @StringOrListConverter() required final List<String> iAm,
    @StringOrListConverter() required final List<String> iTendTo,
    @StringOrListConverter() required final List<String> typicalSituations,
    @StringOrListConverter() required final List<String> watchOuts,
    @StringOrListConverter() required final List<String> toRealizePotential,
    required final String selfDirection,
  }) = _$DomainBlockImpl;

  factory _DomainBlock.fromJson(Map<String, dynamic> json) =
      _$DomainBlockImpl.fromJson;

  @override
  String get title;
  @override
  @StringOrListConverter()
  List<String> get iAm;
  @override
  @StringOrListConverter()
  List<String> get iTendTo;
  @override
  @StringOrListConverter()
  List<String> get typicalSituations;
  @override
  @StringOrListConverter()
  List<String> get watchOuts;
  @override
  @StringOrListConverter()
  List<String> get toRealizePotential;
  @override
  String get selfDirection;

  /// Create a copy of DomainBlock
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DomainBlockImplCopyWith<_$DomainBlockImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AlignmentIndicators _$AlignmentIndicatorsFromJson(Map<String, dynamic> json) {
  return _AlignmentIndicators.fromJson(json);
}

/// @nodoc
mixin _$AlignmentIndicators {
  List<String> get aligned => throw _privateConstructorUsedError;
  List<String> get unaligned => throw _privateConstructorUsedError;

  /// Serializes this AlignmentIndicators to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AlignmentIndicators
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AlignmentIndicatorsCopyWith<AlignmentIndicators> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AlignmentIndicatorsCopyWith<$Res> {
  factory $AlignmentIndicatorsCopyWith(
    AlignmentIndicators value,
    $Res Function(AlignmentIndicators) then,
  ) = _$AlignmentIndicatorsCopyWithImpl<$Res, AlignmentIndicators>;
  @useResult
  $Res call({List<String> aligned, List<String> unaligned});
}

/// @nodoc
class _$AlignmentIndicatorsCopyWithImpl<$Res, $Val extends AlignmentIndicators>
    implements $AlignmentIndicatorsCopyWith<$Res> {
  _$AlignmentIndicatorsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AlignmentIndicators
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? aligned = null, Object? unaligned = null}) {
    return _then(
      _value.copyWith(
            aligned: null == aligned
                ? _value.aligned
                : aligned // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            unaligned: null == unaligned
                ? _value.unaligned
                : unaligned // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AlignmentIndicatorsImplCopyWith<$Res>
    implements $AlignmentIndicatorsCopyWith<$Res> {
  factory _$$AlignmentIndicatorsImplCopyWith(
    _$AlignmentIndicatorsImpl value,
    $Res Function(_$AlignmentIndicatorsImpl) then,
  ) = __$$AlignmentIndicatorsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<String> aligned, List<String> unaligned});
}

/// @nodoc
class __$$AlignmentIndicatorsImplCopyWithImpl<$Res>
    extends _$AlignmentIndicatorsCopyWithImpl<$Res, _$AlignmentIndicatorsImpl>
    implements _$$AlignmentIndicatorsImplCopyWith<$Res> {
  __$$AlignmentIndicatorsImplCopyWithImpl(
    _$AlignmentIndicatorsImpl _value,
    $Res Function(_$AlignmentIndicatorsImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AlignmentIndicators
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? aligned = null, Object? unaligned = null}) {
    return _then(
      _$AlignmentIndicatorsImpl(
        aligned: null == aligned
            ? _value._aligned
            : aligned // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        unaligned: null == unaligned
            ? _value._unaligned
            : unaligned // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AlignmentIndicatorsImpl implements _AlignmentIndicators {
  const _$AlignmentIndicatorsImpl({
    required final List<String> aligned,
    required final List<String> unaligned,
  }) : _aligned = aligned,
       _unaligned = unaligned;

  factory _$AlignmentIndicatorsImpl.fromJson(Map<String, dynamic> json) =>
      _$$AlignmentIndicatorsImplFromJson(json);

  final List<String> _aligned;
  @override
  List<String> get aligned {
    if (_aligned is EqualUnmodifiableListView) return _aligned;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_aligned);
  }

  final List<String> _unaligned;
  @override
  List<String> get unaligned {
    if (_unaligned is EqualUnmodifiableListView) return _unaligned;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_unaligned);
  }

  @override
  String toString() {
    return 'AlignmentIndicators(aligned: $aligned, unaligned: $unaligned)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AlignmentIndicatorsImpl &&
            const DeepCollectionEquality().equals(other._aligned, _aligned) &&
            const DeepCollectionEquality().equals(
              other._unaligned,
              _unaligned,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    const DeepCollectionEquality().hash(_aligned),
    const DeepCollectionEquality().hash(_unaligned),
  );

  /// Create a copy of AlignmentIndicators
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AlignmentIndicatorsImplCopyWith<_$AlignmentIndicatorsImpl> get copyWith =>
      __$$AlignmentIndicatorsImplCopyWithImpl<_$AlignmentIndicatorsImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AlignmentIndicatorsImplToJson(this);
  }
}

abstract class _AlignmentIndicators implements AlignmentIndicators {
  const factory _AlignmentIndicators({
    required final List<String> aligned,
    required final List<String> unaligned,
  }) = _$AlignmentIndicatorsImpl;

  factory _AlignmentIndicators.fromJson(Map<String, dynamic> json) =
      _$AlignmentIndicatorsImpl.fromJson;

  @override
  List<String> get aligned;
  @override
  List<String> get unaligned;

  /// Create a copy of AlignmentIndicators
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AlignmentIndicatorsImplCopyWith<_$AlignmentIndicatorsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MetaOutput _$MetaOutputFromJson(Map<String, dynamic> json) {
  return _MetaOutput.fromJson(json);
}

/// @nodoc
mixin _$MetaOutput {
  String get generatedAt => throw _privateConstructorUsedError;
  String get modelVersion => throw _privateConstructorUsedError;
  String get promptVersion => throw _privateConstructorUsedError;
  int get schemaVersion => throw _privateConstructorUsedError;
  String? get identificationVersion =>
      throw _privateConstructorUsedError; // '1.0' or '2.0' for Center/Orbit
  String? get regenerationType =>
      throw _privateConstructorUsedError; // 'full' or 'assessment_driven'
  Map<String, dynamic>? get changedMappings =>
      throw _privateConstructorUsedError;

  /// Serializes this MetaOutput to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of MetaOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MetaOutputCopyWith<MetaOutput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MetaOutputCopyWith<$Res> {
  factory $MetaOutputCopyWith(
    MetaOutput value,
    $Res Function(MetaOutput) then,
  ) = _$MetaOutputCopyWithImpl<$Res, MetaOutput>;
  @useResult
  $Res call({
    String generatedAt,
    String modelVersion,
    String promptVersion,
    int schemaVersion,
    String? identificationVersion,
    String? regenerationType,
    Map<String, dynamic>? changedMappings,
  });
}

/// @nodoc
class _$MetaOutputCopyWithImpl<$Res, $Val extends MetaOutput>
    implements $MetaOutputCopyWith<$Res> {
  _$MetaOutputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MetaOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? generatedAt = null,
    Object? modelVersion = null,
    Object? promptVersion = null,
    Object? schemaVersion = null,
    Object? identificationVersion = freezed,
    Object? regenerationType = freezed,
    Object? changedMappings = freezed,
  }) {
    return _then(
      _value.copyWith(
            generatedAt: null == generatedAt
                ? _value.generatedAt
                : generatedAt // ignore: cast_nullable_to_non_nullable
                      as String,
            modelVersion: null == modelVersion
                ? _value.modelVersion
                : modelVersion // ignore: cast_nullable_to_non_nullable
                      as String,
            promptVersion: null == promptVersion
                ? _value.promptVersion
                : promptVersion // ignore: cast_nullable_to_non_nullable
                      as String,
            schemaVersion: null == schemaVersion
                ? _value.schemaVersion
                : schemaVersion // ignore: cast_nullable_to_non_nullable
                      as int,
            identificationVersion: freezed == identificationVersion
                ? _value.identificationVersion
                : identificationVersion // ignore: cast_nullable_to_non_nullable
                      as String?,
            regenerationType: freezed == regenerationType
                ? _value.regenerationType
                : regenerationType // ignore: cast_nullable_to_non_nullable
                      as String?,
            changedMappings: freezed == changedMappings
                ? _value.changedMappings
                : changedMappings // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$MetaOutputImplCopyWith<$Res>
    implements $MetaOutputCopyWith<$Res> {
  factory _$$MetaOutputImplCopyWith(
    _$MetaOutputImpl value,
    $Res Function(_$MetaOutputImpl) then,
  ) = __$$MetaOutputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String generatedAt,
    String modelVersion,
    String promptVersion,
    int schemaVersion,
    String? identificationVersion,
    String? regenerationType,
    Map<String, dynamic>? changedMappings,
  });
}

/// @nodoc
class __$$MetaOutputImplCopyWithImpl<$Res>
    extends _$MetaOutputCopyWithImpl<$Res, _$MetaOutputImpl>
    implements _$$MetaOutputImplCopyWith<$Res> {
  __$$MetaOutputImplCopyWithImpl(
    _$MetaOutputImpl _value,
    $Res Function(_$MetaOutputImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of MetaOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? generatedAt = null,
    Object? modelVersion = null,
    Object? promptVersion = null,
    Object? schemaVersion = null,
    Object? identificationVersion = freezed,
    Object? regenerationType = freezed,
    Object? changedMappings = freezed,
  }) {
    return _then(
      _$MetaOutputImpl(
        generatedAt: null == generatedAt
            ? _value.generatedAt
            : generatedAt // ignore: cast_nullable_to_non_nullable
                  as String,
        modelVersion: null == modelVersion
            ? _value.modelVersion
            : modelVersion // ignore: cast_nullable_to_non_nullable
                  as String,
        promptVersion: null == promptVersion
            ? _value.promptVersion
            : promptVersion // ignore: cast_nullable_to_non_nullable
                  as String,
        schemaVersion: null == schemaVersion
            ? _value.schemaVersion
            : schemaVersion // ignore: cast_nullable_to_non_nullable
                  as int,
        identificationVersion: freezed == identificationVersion
            ? _value.identificationVersion
            : identificationVersion // ignore: cast_nullable_to_non_nullable
                  as String?,
        regenerationType: freezed == regenerationType
            ? _value.regenerationType
            : regenerationType // ignore: cast_nullable_to_non_nullable
                  as String?,
        changedMappings: freezed == changedMappings
            ? _value._changedMappings
            : changedMappings // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$MetaOutputImpl implements _MetaOutput {
  const _$MetaOutputImpl({
    required this.generatedAt,
    required this.modelVersion,
    required this.promptVersion,
    required this.schemaVersion,
    this.identificationVersion,
    this.regenerationType,
    final Map<String, dynamic>? changedMappings,
  }) : _changedMappings = changedMappings;

  factory _$MetaOutputImpl.fromJson(Map<String, dynamic> json) =>
      _$$MetaOutputImplFromJson(json);

  @override
  final String generatedAt;
  @override
  final String modelVersion;
  @override
  final String promptVersion;
  @override
  final int schemaVersion;
  @override
  final String? identificationVersion;
  // '1.0' or '2.0' for Center/Orbit
  @override
  final String? regenerationType;
  // 'full' or 'assessment_driven'
  final Map<String, dynamic>? _changedMappings;
  // 'full' or 'assessment_driven'
  @override
  Map<String, dynamic>? get changedMappings {
    final value = _changedMappings;
    if (value == null) return null;
    if (_changedMappings is EqualUnmodifiableMapView) return _changedMappings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'MetaOutput(generatedAt: $generatedAt, modelVersion: $modelVersion, promptVersion: $promptVersion, schemaVersion: $schemaVersion, identificationVersion: $identificationVersion, regenerationType: $regenerationType, changedMappings: $changedMappings)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MetaOutputImpl &&
            (identical(other.generatedAt, generatedAt) ||
                other.generatedAt == generatedAt) &&
            (identical(other.modelVersion, modelVersion) ||
                other.modelVersion == modelVersion) &&
            (identical(other.promptVersion, promptVersion) ||
                other.promptVersion == promptVersion) &&
            (identical(other.schemaVersion, schemaVersion) ||
                other.schemaVersion == schemaVersion) &&
            (identical(other.identificationVersion, identificationVersion) ||
                other.identificationVersion == identificationVersion) &&
            (identical(other.regenerationType, regenerationType) ||
                other.regenerationType == regenerationType) &&
            const DeepCollectionEquality().equals(
              other._changedMappings,
              _changedMappings,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    generatedAt,
    modelVersion,
    promptVersion,
    schemaVersion,
    identificationVersion,
    regenerationType,
    const DeepCollectionEquality().hash(_changedMappings),
  );

  /// Create a copy of MetaOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MetaOutputImplCopyWith<_$MetaOutputImpl> get copyWith =>
      __$$MetaOutputImplCopyWithImpl<_$MetaOutputImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MetaOutputImplToJson(this);
  }
}

abstract class _MetaOutput implements MetaOutput {
  const factory _MetaOutput({
    required final String generatedAt,
    required final String modelVersion,
    required final String promptVersion,
    required final int schemaVersion,
    final String? identificationVersion,
    final String? regenerationType,
    final Map<String, dynamic>? changedMappings,
  }) = _$MetaOutputImpl;

  factory _MetaOutput.fromJson(Map<String, dynamic> json) =
      _$MetaOutputImpl.fromJson;

  @override
  String get generatedAt;
  @override
  String get modelVersion;
  @override
  String get promptVersion;
  @override
  int get schemaVersion;
  @override
  String? get identificationVersion; // '1.0' or '2.0' for Center/Orbit
  @override
  String? get regenerationType; // 'full' or 'assessment_driven'
  @override
  Map<String, dynamic>? get changedMappings;

  /// Create a copy of MetaOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MetaOutputImplCopyWith<_$MetaOutputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DeltaSummary _$DeltaSummaryFromJson(Map<String, dynamic> json) {
  return _DeltaSummary.fromJson(json);
}

/// @nodoc
mixin _$DeltaSummary {
  List<DeltaChange> get changes => throw _privateConstructorUsedError;
  Map<String, dynamic>? get changedMappings =>
      throw _privateConstructorUsedError;
  String? get timestamp => throw _privateConstructorUsedError;

  /// Serializes this DeltaSummary to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of DeltaSummary
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DeltaSummaryCopyWith<DeltaSummary> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeltaSummaryCopyWith<$Res> {
  factory $DeltaSummaryCopyWith(
    DeltaSummary value,
    $Res Function(DeltaSummary) then,
  ) = _$DeltaSummaryCopyWithImpl<$Res, DeltaSummary>;
  @useResult
  $Res call({
    List<DeltaChange> changes,
    Map<String, dynamic>? changedMappings,
    String? timestamp,
  });
}

/// @nodoc
class _$DeltaSummaryCopyWithImpl<$Res, $Val extends DeltaSummary>
    implements $DeltaSummaryCopyWith<$Res> {
  _$DeltaSummaryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DeltaSummary
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? changes = null,
    Object? changedMappings = freezed,
    Object? timestamp = freezed,
  }) {
    return _then(
      _value.copyWith(
            changes: null == changes
                ? _value.changes
                : changes // ignore: cast_nullable_to_non_nullable
                      as List<DeltaChange>,
            changedMappings: freezed == changedMappings
                ? _value.changedMappings
                : changedMappings // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>?,
            timestamp: freezed == timestamp
                ? _value.timestamp
                : timestamp // ignore: cast_nullable_to_non_nullable
                      as String?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$DeltaSummaryImplCopyWith<$Res>
    implements $DeltaSummaryCopyWith<$Res> {
  factory _$$DeltaSummaryImplCopyWith(
    _$DeltaSummaryImpl value,
    $Res Function(_$DeltaSummaryImpl) then,
  ) = __$$DeltaSummaryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    List<DeltaChange> changes,
    Map<String, dynamic>? changedMappings,
    String? timestamp,
  });
}

/// @nodoc
class __$$DeltaSummaryImplCopyWithImpl<$Res>
    extends _$DeltaSummaryCopyWithImpl<$Res, _$DeltaSummaryImpl>
    implements _$$DeltaSummaryImplCopyWith<$Res> {
  __$$DeltaSummaryImplCopyWithImpl(
    _$DeltaSummaryImpl _value,
    $Res Function(_$DeltaSummaryImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DeltaSummary
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? changes = null,
    Object? changedMappings = freezed,
    Object? timestamp = freezed,
  }) {
    return _then(
      _$DeltaSummaryImpl(
        changes: null == changes
            ? _value._changes
            : changes // ignore: cast_nullable_to_non_nullable
                  as List<DeltaChange>,
        changedMappings: freezed == changedMappings
            ? _value._changedMappings
            : changedMappings // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>?,
        timestamp: freezed == timestamp
            ? _value.timestamp
            : timestamp // ignore: cast_nullable_to_non_nullable
                  as String?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$DeltaSummaryImpl implements _DeltaSummary {
  const _$DeltaSummaryImpl({
    final List<DeltaChange> changes = const [],
    final Map<String, dynamic>? changedMappings,
    this.timestamp,
  }) : _changes = changes,
       _changedMappings = changedMappings;

  factory _$DeltaSummaryImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeltaSummaryImplFromJson(json);

  final List<DeltaChange> _changes;
  @override
  @JsonKey()
  List<DeltaChange> get changes {
    if (_changes is EqualUnmodifiableListView) return _changes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_changes);
  }

  final Map<String, dynamic>? _changedMappings;
  @override
  Map<String, dynamic>? get changedMappings {
    final value = _changedMappings;
    if (value == null) return null;
    if (_changedMappings is EqualUnmodifiableMapView) return _changedMappings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final String? timestamp;

  @override
  String toString() {
    return 'DeltaSummary(changes: $changes, changedMappings: $changedMappings, timestamp: $timestamp)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeltaSummaryImpl &&
            const DeepCollectionEquality().equals(other._changes, _changes) &&
            const DeepCollectionEquality().equals(
              other._changedMappings,
              _changedMappings,
            ) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    const DeepCollectionEquality().hash(_changes),
    const DeepCollectionEquality().hash(_changedMappings),
    timestamp,
  );

  /// Create a copy of DeltaSummary
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DeltaSummaryImplCopyWith<_$DeltaSummaryImpl> get copyWith =>
      __$$DeltaSummaryImplCopyWithImpl<_$DeltaSummaryImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeltaSummaryImplToJson(this);
  }
}

abstract class _DeltaSummary implements DeltaSummary {
  const factory _DeltaSummary({
    final List<DeltaChange> changes,
    final Map<String, dynamic>? changedMappings,
    final String? timestamp,
  }) = _$DeltaSummaryImpl;

  factory _DeltaSummary.fromJson(Map<String, dynamic> json) =
      _$DeltaSummaryImpl.fromJson;

  @override
  List<DeltaChange> get changes;
  @override
  Map<String, dynamic>? get changedMappings;
  @override
  String? get timestamp;

  /// Create a copy of DeltaSummary
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DeltaSummaryImplCopyWith<_$DeltaSummaryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DeltaChange _$DeltaChangeFromJson(Map<String, dynamic> json) {
  return _DeltaChange.fromJson(json);
}

/// @nodoc
mixin _$DeltaChange {
  String get what => throw _privateConstructorUsedError;
  String? get from => throw _privateConstructorUsedError;
  String? get to => throw _privateConstructorUsedError;
  List<String> get triggeredBy => throw _privateConstructorUsedError;

  /// Serializes this DeltaChange to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of DeltaChange
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DeltaChangeCopyWith<DeltaChange> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeltaChangeCopyWith<$Res> {
  factory $DeltaChangeCopyWith(
    DeltaChange value,
    $Res Function(DeltaChange) then,
  ) = _$DeltaChangeCopyWithImpl<$Res, DeltaChange>;
  @useResult
  $Res call({String what, String? from, String? to, List<String> triggeredBy});
}

/// @nodoc
class _$DeltaChangeCopyWithImpl<$Res, $Val extends DeltaChange>
    implements $DeltaChangeCopyWith<$Res> {
  _$DeltaChangeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DeltaChange
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? what = null,
    Object? from = freezed,
    Object? to = freezed,
    Object? triggeredBy = null,
  }) {
    return _then(
      _value.copyWith(
            what: null == what
                ? _value.what
                : what // ignore: cast_nullable_to_non_nullable
                      as String,
            from: freezed == from
                ? _value.from
                : from // ignore: cast_nullable_to_non_nullable
                      as String?,
            to: freezed == to
                ? _value.to
                : to // ignore: cast_nullable_to_non_nullable
                      as String?,
            triggeredBy: null == triggeredBy
                ? _value.triggeredBy
                : triggeredBy // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$DeltaChangeImplCopyWith<$Res>
    implements $DeltaChangeCopyWith<$Res> {
  factory _$$DeltaChangeImplCopyWith(
    _$DeltaChangeImpl value,
    $Res Function(_$DeltaChangeImpl) then,
  ) = __$$DeltaChangeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String what, String? from, String? to, List<String> triggeredBy});
}

/// @nodoc
class __$$DeltaChangeImplCopyWithImpl<$Res>
    extends _$DeltaChangeCopyWithImpl<$Res, _$DeltaChangeImpl>
    implements _$$DeltaChangeImplCopyWith<$Res> {
  __$$DeltaChangeImplCopyWithImpl(
    _$DeltaChangeImpl _value,
    $Res Function(_$DeltaChangeImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DeltaChange
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? what = null,
    Object? from = freezed,
    Object? to = freezed,
    Object? triggeredBy = null,
  }) {
    return _then(
      _$DeltaChangeImpl(
        what: null == what
            ? _value.what
            : what // ignore: cast_nullable_to_non_nullable
                  as String,
        from: freezed == from
            ? _value.from
            : from // ignore: cast_nullable_to_non_nullable
                  as String?,
        to: freezed == to
            ? _value.to
            : to // ignore: cast_nullable_to_non_nullable
                  as String?,
        triggeredBy: null == triggeredBy
            ? _value._triggeredBy
            : triggeredBy // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$DeltaChangeImpl implements _DeltaChange {
  const _$DeltaChangeImpl({
    required this.what,
    this.from,
    this.to,
    final List<String> triggeredBy = const [],
  }) : _triggeredBy = triggeredBy;

  factory _$DeltaChangeImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeltaChangeImplFromJson(json);

  @override
  final String what;
  @override
  final String? from;
  @override
  final String? to;
  final List<String> _triggeredBy;
  @override
  @JsonKey()
  List<String> get triggeredBy {
    if (_triggeredBy is EqualUnmodifiableListView) return _triggeredBy;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_triggeredBy);
  }

  @override
  String toString() {
    return 'DeltaChange(what: $what, from: $from, to: $to, triggeredBy: $triggeredBy)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeltaChangeImpl &&
            (identical(other.what, what) || other.what == what) &&
            (identical(other.from, from) || other.from == from) &&
            (identical(other.to, to) || other.to == to) &&
            const DeepCollectionEquality().equals(
              other._triggeredBy,
              _triggeredBy,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    what,
    from,
    to,
    const DeepCollectionEquality().hash(_triggeredBy),
  );

  /// Create a copy of DeltaChange
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DeltaChangeImplCopyWith<_$DeltaChangeImpl> get copyWith =>
      __$$DeltaChangeImplCopyWithImpl<_$DeltaChangeImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeltaChangeImplToJson(this);
  }
}

abstract class _DeltaChange implements DeltaChange {
  const factory _DeltaChange({
    required final String what,
    final String? from,
    final String? to,
    final List<String> triggeredBy,
  }) = _$DeltaChangeImpl;

  factory _DeltaChange.fromJson(Map<String, dynamic> json) =
      _$DeltaChangeImpl.fromJson;

  @override
  String get what;
  @override
  String? get from;
  @override
  String? get to;
  @override
  List<String> get triggeredBy;

  /// Create a copy of DeltaChange
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DeltaChangeImplCopyWith<_$DeltaChangeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

IdentificationV2 _$IdentificationV2FromJson(Map<String, dynamic> json) {
  return _IdentificationV2.fromJson(json);
}

/// @nodoc
mixin _$IdentificationV2 {
  String get version => throw _privateConstructorUsedError;
  ArchetypeDynamics? get ego => throw _privateConstructorUsedError;
  ArchetypeDynamics? get persona => throw _privateConstructorUsedError;
  ArchetypeDynamics? get shadow => throw _privateConstructorUsedError;
  ArchetypeDynamics? get shadowVirtue => throw _privateConstructorUsedError;
  ArchetypeDynamics? get feelingFunction => throw _privateConstructorUsedError;
  ArchetypeDynamics? get erosAxis => throw _privateConstructorUsedError;

  /// Serializes this IdentificationV2 to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of IdentificationV2
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $IdentificationV2CopyWith<IdentificationV2> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IdentificationV2CopyWith<$Res> {
  factory $IdentificationV2CopyWith(
    IdentificationV2 value,
    $Res Function(IdentificationV2) then,
  ) = _$IdentificationV2CopyWithImpl<$Res, IdentificationV2>;
  @useResult
  $Res call({
    String version,
    ArchetypeDynamics? ego,
    ArchetypeDynamics? persona,
    ArchetypeDynamics? shadow,
    ArchetypeDynamics? shadowVirtue,
    ArchetypeDynamics? feelingFunction,
    ArchetypeDynamics? erosAxis,
  });

  $ArchetypeDynamicsCopyWith<$Res>? get ego;
  $ArchetypeDynamicsCopyWith<$Res>? get persona;
  $ArchetypeDynamicsCopyWith<$Res>? get shadow;
  $ArchetypeDynamicsCopyWith<$Res>? get shadowVirtue;
  $ArchetypeDynamicsCopyWith<$Res>? get feelingFunction;
  $ArchetypeDynamicsCopyWith<$Res>? get erosAxis;
}

/// @nodoc
class _$IdentificationV2CopyWithImpl<$Res, $Val extends IdentificationV2>
    implements $IdentificationV2CopyWith<$Res> {
  _$IdentificationV2CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of IdentificationV2
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? version = null,
    Object? ego = freezed,
    Object? persona = freezed,
    Object? shadow = freezed,
    Object? shadowVirtue = freezed,
    Object? feelingFunction = freezed,
    Object? erosAxis = freezed,
  }) {
    return _then(
      _value.copyWith(
            version: null == version
                ? _value.version
                : version // ignore: cast_nullable_to_non_nullable
                      as String,
            ego: freezed == ego
                ? _value.ego
                : ego // ignore: cast_nullable_to_non_nullable
                      as ArchetypeDynamics?,
            persona: freezed == persona
                ? _value.persona
                : persona // ignore: cast_nullable_to_non_nullable
                      as ArchetypeDynamics?,
            shadow: freezed == shadow
                ? _value.shadow
                : shadow // ignore: cast_nullable_to_non_nullable
                      as ArchetypeDynamics?,
            shadowVirtue: freezed == shadowVirtue
                ? _value.shadowVirtue
                : shadowVirtue // ignore: cast_nullable_to_non_nullable
                      as ArchetypeDynamics?,
            feelingFunction: freezed == feelingFunction
                ? _value.feelingFunction
                : feelingFunction // ignore: cast_nullable_to_non_nullable
                      as ArchetypeDynamics?,
            erosAxis: freezed == erosAxis
                ? _value.erosAxis
                : erosAxis // ignore: cast_nullable_to_non_nullable
                      as ArchetypeDynamics?,
          )
          as $Val,
    );
  }

  /// Create a copy of IdentificationV2
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArchetypeDynamicsCopyWith<$Res>? get ego {
    if (_value.ego == null) {
      return null;
    }

    return $ArchetypeDynamicsCopyWith<$Res>(_value.ego!, (value) {
      return _then(_value.copyWith(ego: value) as $Val);
    });
  }

  /// Create a copy of IdentificationV2
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArchetypeDynamicsCopyWith<$Res>? get persona {
    if (_value.persona == null) {
      return null;
    }

    return $ArchetypeDynamicsCopyWith<$Res>(_value.persona!, (value) {
      return _then(_value.copyWith(persona: value) as $Val);
    });
  }

  /// Create a copy of IdentificationV2
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArchetypeDynamicsCopyWith<$Res>? get shadow {
    if (_value.shadow == null) {
      return null;
    }

    return $ArchetypeDynamicsCopyWith<$Res>(_value.shadow!, (value) {
      return _then(_value.copyWith(shadow: value) as $Val);
    });
  }

  /// Create a copy of IdentificationV2
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArchetypeDynamicsCopyWith<$Res>? get shadowVirtue {
    if (_value.shadowVirtue == null) {
      return null;
    }

    return $ArchetypeDynamicsCopyWith<$Res>(_value.shadowVirtue!, (value) {
      return _then(_value.copyWith(shadowVirtue: value) as $Val);
    });
  }

  /// Create a copy of IdentificationV2
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArchetypeDynamicsCopyWith<$Res>? get feelingFunction {
    if (_value.feelingFunction == null) {
      return null;
    }

    return $ArchetypeDynamicsCopyWith<$Res>(_value.feelingFunction!, (value) {
      return _then(_value.copyWith(feelingFunction: value) as $Val);
    });
  }

  /// Create a copy of IdentificationV2
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArchetypeDynamicsCopyWith<$Res>? get erosAxis {
    if (_value.erosAxis == null) {
      return null;
    }

    return $ArchetypeDynamicsCopyWith<$Res>(_value.erosAxis!, (value) {
      return _then(_value.copyWith(erosAxis: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$IdentificationV2ImplCopyWith<$Res>
    implements $IdentificationV2CopyWith<$Res> {
  factory _$$IdentificationV2ImplCopyWith(
    _$IdentificationV2Impl value,
    $Res Function(_$IdentificationV2Impl) then,
  ) = __$$IdentificationV2ImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String version,
    ArchetypeDynamics? ego,
    ArchetypeDynamics? persona,
    ArchetypeDynamics? shadow,
    ArchetypeDynamics? shadowVirtue,
    ArchetypeDynamics? feelingFunction,
    ArchetypeDynamics? erosAxis,
  });

  @override
  $ArchetypeDynamicsCopyWith<$Res>? get ego;
  @override
  $ArchetypeDynamicsCopyWith<$Res>? get persona;
  @override
  $ArchetypeDynamicsCopyWith<$Res>? get shadow;
  @override
  $ArchetypeDynamicsCopyWith<$Res>? get shadowVirtue;
  @override
  $ArchetypeDynamicsCopyWith<$Res>? get feelingFunction;
  @override
  $ArchetypeDynamicsCopyWith<$Res>? get erosAxis;
}

/// @nodoc
class __$$IdentificationV2ImplCopyWithImpl<$Res>
    extends _$IdentificationV2CopyWithImpl<$Res, _$IdentificationV2Impl>
    implements _$$IdentificationV2ImplCopyWith<$Res> {
  __$$IdentificationV2ImplCopyWithImpl(
    _$IdentificationV2Impl _value,
    $Res Function(_$IdentificationV2Impl) _then,
  ) : super(_value, _then);

  /// Create a copy of IdentificationV2
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? version = null,
    Object? ego = freezed,
    Object? persona = freezed,
    Object? shadow = freezed,
    Object? shadowVirtue = freezed,
    Object? feelingFunction = freezed,
    Object? erosAxis = freezed,
  }) {
    return _then(
      _$IdentificationV2Impl(
        version: null == version
            ? _value.version
            : version // ignore: cast_nullable_to_non_nullable
                  as String,
        ego: freezed == ego
            ? _value.ego
            : ego // ignore: cast_nullable_to_non_nullable
                  as ArchetypeDynamics?,
        persona: freezed == persona
            ? _value.persona
            : persona // ignore: cast_nullable_to_non_nullable
                  as ArchetypeDynamics?,
        shadow: freezed == shadow
            ? _value.shadow
            : shadow // ignore: cast_nullable_to_non_nullable
                  as ArchetypeDynamics?,
        shadowVirtue: freezed == shadowVirtue
            ? _value.shadowVirtue
            : shadowVirtue // ignore: cast_nullable_to_non_nullable
                  as ArchetypeDynamics?,
        feelingFunction: freezed == feelingFunction
            ? _value.feelingFunction
            : feelingFunction // ignore: cast_nullable_to_non_nullable
                  as ArchetypeDynamics?,
        erosAxis: freezed == erosAxis
            ? _value.erosAxis
            : erosAxis // ignore: cast_nullable_to_non_nullable
                  as ArchetypeDynamics?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$IdentificationV2Impl implements _IdentificationV2 {
  const _$IdentificationV2Impl({
    this.version = '2.0',
    this.ego,
    this.persona,
    this.shadow,
    this.shadowVirtue,
    this.feelingFunction,
    this.erosAxis,
  });

  factory _$IdentificationV2Impl.fromJson(Map<String, dynamic> json) =>
      _$$IdentificationV2ImplFromJson(json);

  @override
  @JsonKey()
  final String version;
  @override
  final ArchetypeDynamics? ego;
  @override
  final ArchetypeDynamics? persona;
  @override
  final ArchetypeDynamics? shadow;
  @override
  final ArchetypeDynamics? shadowVirtue;
  @override
  final ArchetypeDynamics? feelingFunction;
  @override
  final ArchetypeDynamics? erosAxis;

  @override
  String toString() {
    return 'IdentificationV2(version: $version, ego: $ego, persona: $persona, shadow: $shadow, shadowVirtue: $shadowVirtue, feelingFunction: $feelingFunction, erosAxis: $erosAxis)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IdentificationV2Impl &&
            (identical(other.version, version) || other.version == version) &&
            (identical(other.ego, ego) || other.ego == ego) &&
            (identical(other.persona, persona) || other.persona == persona) &&
            (identical(other.shadow, shadow) || other.shadow == shadow) &&
            (identical(other.shadowVirtue, shadowVirtue) ||
                other.shadowVirtue == shadowVirtue) &&
            (identical(other.feelingFunction, feelingFunction) ||
                other.feelingFunction == feelingFunction) &&
            (identical(other.erosAxis, erosAxis) ||
                other.erosAxis == erosAxis));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    version,
    ego,
    persona,
    shadow,
    shadowVirtue,
    feelingFunction,
    erosAxis,
  );

  /// Create a copy of IdentificationV2
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IdentificationV2ImplCopyWith<_$IdentificationV2Impl> get copyWith =>
      __$$IdentificationV2ImplCopyWithImpl<_$IdentificationV2Impl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$IdentificationV2ImplToJson(this);
  }
}

abstract class _IdentificationV2 implements IdentificationV2 {
  const factory _IdentificationV2({
    final String version,
    final ArchetypeDynamics? ego,
    final ArchetypeDynamics? persona,
    final ArchetypeDynamics? shadow,
    final ArchetypeDynamics? shadowVirtue,
    final ArchetypeDynamics? feelingFunction,
    final ArchetypeDynamics? erosAxis,
  }) = _$IdentificationV2Impl;

  factory _IdentificationV2.fromJson(Map<String, dynamic> json) =
      _$IdentificationV2Impl.fromJson;

  @override
  String get version;
  @override
  ArchetypeDynamics? get ego;
  @override
  ArchetypeDynamics? get persona;
  @override
  ArchetypeDynamics? get shadow;
  @override
  ArchetypeDynamics? get shadowVirtue;
  @override
  ArchetypeDynamics? get feelingFunction;
  @override
  ArchetypeDynamics? get erosAxis;

  /// Create a copy of IdentificationV2
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IdentificationV2ImplCopyWith<_$IdentificationV2Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

ArchetypeDynamics _$ArchetypeDynamicsFromJson(Map<String, dynamic> json) {
  return _ArchetypeDynamics.fromJson(json);
}

/// @nodoc
mixin _$ArchetypeDynamics {
  CenterPosition get center => throw _privateConstructorUsedError;
  List<OrbitEntry> get orbit => throw _privateConstructorUsedError;
  List<CompensationEntry> get compensations =>
      throw _privateConstructorUsedError;

  /// Serializes this ArchetypeDynamics to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ArchetypeDynamics
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ArchetypeDynamicsCopyWith<ArchetypeDynamics> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ArchetypeDynamicsCopyWith<$Res> {
  factory $ArchetypeDynamicsCopyWith(
    ArchetypeDynamics value,
    $Res Function(ArchetypeDynamics) then,
  ) = _$ArchetypeDynamicsCopyWithImpl<$Res, ArchetypeDynamics>;
  @useResult
  $Res call({
    CenterPosition center,
    List<OrbitEntry> orbit,
    List<CompensationEntry> compensations,
  });

  $CenterPositionCopyWith<$Res> get center;
}

/// @nodoc
class _$ArchetypeDynamicsCopyWithImpl<$Res, $Val extends ArchetypeDynamics>
    implements $ArchetypeDynamicsCopyWith<$Res> {
  _$ArchetypeDynamicsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ArchetypeDynamics
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? center = null,
    Object? orbit = null,
    Object? compensations = null,
  }) {
    return _then(
      _value.copyWith(
            center: null == center
                ? _value.center
                : center // ignore: cast_nullable_to_non_nullable
                      as CenterPosition,
            orbit: null == orbit
                ? _value.orbit
                : orbit // ignore: cast_nullable_to_non_nullable
                      as List<OrbitEntry>,
            compensations: null == compensations
                ? _value.compensations
                : compensations // ignore: cast_nullable_to_non_nullable
                      as List<CompensationEntry>,
          )
          as $Val,
    );
  }

  /// Create a copy of ArchetypeDynamics
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CenterPositionCopyWith<$Res> get center {
    return $CenterPositionCopyWith<$Res>(_value.center, (value) {
      return _then(_value.copyWith(center: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ArchetypeDynamicsImplCopyWith<$Res>
    implements $ArchetypeDynamicsCopyWith<$Res> {
  factory _$$ArchetypeDynamicsImplCopyWith(
    _$ArchetypeDynamicsImpl value,
    $Res Function(_$ArchetypeDynamicsImpl) then,
  ) = __$$ArchetypeDynamicsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    CenterPosition center,
    List<OrbitEntry> orbit,
    List<CompensationEntry> compensations,
  });

  @override
  $CenterPositionCopyWith<$Res> get center;
}

/// @nodoc
class __$$ArchetypeDynamicsImplCopyWithImpl<$Res>
    extends _$ArchetypeDynamicsCopyWithImpl<$Res, _$ArchetypeDynamicsImpl>
    implements _$$ArchetypeDynamicsImplCopyWith<$Res> {
  __$$ArchetypeDynamicsImplCopyWithImpl(
    _$ArchetypeDynamicsImpl _value,
    $Res Function(_$ArchetypeDynamicsImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ArchetypeDynamics
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? center = null,
    Object? orbit = null,
    Object? compensations = null,
  }) {
    return _then(
      _$ArchetypeDynamicsImpl(
        center: null == center
            ? _value.center
            : center // ignore: cast_nullable_to_non_nullable
                  as CenterPosition,
        orbit: null == orbit
            ? _value._orbit
            : orbit // ignore: cast_nullable_to_non_nullable
                  as List<OrbitEntry>,
        compensations: null == compensations
            ? _value._compensations
            : compensations // ignore: cast_nullable_to_non_nullable
                  as List<CompensationEntry>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ArchetypeDynamicsImpl implements _ArchetypeDynamics {
  const _$ArchetypeDynamicsImpl({
    required this.center,
    final List<OrbitEntry> orbit = const [],
    final List<CompensationEntry> compensations = const [],
  }) : _orbit = orbit,
       _compensations = compensations;

  factory _$ArchetypeDynamicsImpl.fromJson(Map<String, dynamic> json) =>
      _$$ArchetypeDynamicsImplFromJson(json);

  @override
  final CenterPosition center;
  final List<OrbitEntry> _orbit;
  @override
  @JsonKey()
  List<OrbitEntry> get orbit {
    if (_orbit is EqualUnmodifiableListView) return _orbit;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_orbit);
  }

  final List<CompensationEntry> _compensations;
  @override
  @JsonKey()
  List<CompensationEntry> get compensations {
    if (_compensations is EqualUnmodifiableListView) return _compensations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_compensations);
  }

  @override
  String toString() {
    return 'ArchetypeDynamics(center: $center, orbit: $orbit, compensations: $compensations)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ArchetypeDynamicsImpl &&
            (identical(other.center, center) || other.center == center) &&
            const DeepCollectionEquality().equals(other._orbit, _orbit) &&
            const DeepCollectionEquality().equals(
              other._compensations,
              _compensations,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    center,
    const DeepCollectionEquality().hash(_orbit),
    const DeepCollectionEquality().hash(_compensations),
  );

  /// Create a copy of ArchetypeDynamics
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ArchetypeDynamicsImplCopyWith<_$ArchetypeDynamicsImpl> get copyWith =>
      __$$ArchetypeDynamicsImplCopyWithImpl<_$ArchetypeDynamicsImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$ArchetypeDynamicsImplToJson(this);
  }
}

abstract class _ArchetypeDynamics implements ArchetypeDynamics {
  const factory _ArchetypeDynamics({
    required final CenterPosition center,
    final List<OrbitEntry> orbit,
    final List<CompensationEntry> compensations,
  }) = _$ArchetypeDynamicsImpl;

  factory _ArchetypeDynamics.fromJson(Map<String, dynamic> json) =
      _$ArchetypeDynamicsImpl.fromJson;

  @override
  CenterPosition get center;
  @override
  List<OrbitEntry> get orbit;
  @override
  List<CompensationEntry> get compensations;

  /// Create a copy of ArchetypeDynamics
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ArchetypeDynamicsImplCopyWith<_$ArchetypeDynamicsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CenterPosition _$CenterPositionFromJson(Map<String, dynamic> json) {
  return _CenterPosition.fromJson(json);
}

/// @nodoc
mixin _$CenterPosition {
  String get label => throw _privateConstructorUsedError;
  List<String> get characters => throw _privateConstructorUsedError;
  String get summary => throw _privateConstructorUsedError;
  String? get details => throw _privateConstructorUsedError;
  double get confidence => throw _privateConstructorUsedError;
  DynamicsRationale? get rationale => throw _privateConstructorUsedError;

  /// Serializes this CenterPosition to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CenterPosition
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CenterPositionCopyWith<CenterPosition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CenterPositionCopyWith<$Res> {
  factory $CenterPositionCopyWith(
    CenterPosition value,
    $Res Function(CenterPosition) then,
  ) = _$CenterPositionCopyWithImpl<$Res, CenterPosition>;
  @useResult
  $Res call({
    String label,
    List<String> characters,
    String summary,
    String? details,
    double confidence,
    DynamicsRationale? rationale,
  });

  $DynamicsRationaleCopyWith<$Res>? get rationale;
}

/// @nodoc
class _$CenterPositionCopyWithImpl<$Res, $Val extends CenterPosition>
    implements $CenterPositionCopyWith<$Res> {
  _$CenterPositionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CenterPosition
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? label = null,
    Object? characters = null,
    Object? summary = null,
    Object? details = freezed,
    Object? confidence = null,
    Object? rationale = freezed,
  }) {
    return _then(
      _value.copyWith(
            label: null == label
                ? _value.label
                : label // ignore: cast_nullable_to_non_nullable
                      as String,
            characters: null == characters
                ? _value.characters
                : characters // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            summary: null == summary
                ? _value.summary
                : summary // ignore: cast_nullable_to_non_nullable
                      as String,
            details: freezed == details
                ? _value.details
                : details // ignore: cast_nullable_to_non_nullable
                      as String?,
            confidence: null == confidence
                ? _value.confidence
                : confidence // ignore: cast_nullable_to_non_nullable
                      as double,
            rationale: freezed == rationale
                ? _value.rationale
                : rationale // ignore: cast_nullable_to_non_nullable
                      as DynamicsRationale?,
          )
          as $Val,
    );
  }

  /// Create a copy of CenterPosition
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DynamicsRationaleCopyWith<$Res>? get rationale {
    if (_value.rationale == null) {
      return null;
    }

    return $DynamicsRationaleCopyWith<$Res>(_value.rationale!, (value) {
      return _then(_value.copyWith(rationale: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CenterPositionImplCopyWith<$Res>
    implements $CenterPositionCopyWith<$Res> {
  factory _$$CenterPositionImplCopyWith(
    _$CenterPositionImpl value,
    $Res Function(_$CenterPositionImpl) then,
  ) = __$$CenterPositionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String label,
    List<String> characters,
    String summary,
    String? details,
    double confidence,
    DynamicsRationale? rationale,
  });

  @override
  $DynamicsRationaleCopyWith<$Res>? get rationale;
}

/// @nodoc
class __$$CenterPositionImplCopyWithImpl<$Res>
    extends _$CenterPositionCopyWithImpl<$Res, _$CenterPositionImpl>
    implements _$$CenterPositionImplCopyWith<$Res> {
  __$$CenterPositionImplCopyWithImpl(
    _$CenterPositionImpl _value,
    $Res Function(_$CenterPositionImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of CenterPosition
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? label = null,
    Object? characters = null,
    Object? summary = null,
    Object? details = freezed,
    Object? confidence = null,
    Object? rationale = freezed,
  }) {
    return _then(
      _$CenterPositionImpl(
        label: null == label
            ? _value.label
            : label // ignore: cast_nullable_to_non_nullable
                  as String,
        characters: null == characters
            ? _value._characters
            : characters // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        summary: null == summary
            ? _value.summary
            : summary // ignore: cast_nullable_to_non_nullable
                  as String,
        details: freezed == details
            ? _value.details
            : details // ignore: cast_nullable_to_non_nullable
                  as String?,
        confidence: null == confidence
            ? _value.confidence
            : confidence // ignore: cast_nullable_to_non_nullable
                  as double,
        rationale: freezed == rationale
            ? _value.rationale
            : rationale // ignore: cast_nullable_to_non_nullable
                  as DynamicsRationale?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$CenterPositionImpl implements _CenterPosition {
  const _$CenterPositionImpl({
    required this.label,
    required final List<String> characters,
    required this.summary,
    this.details,
    this.confidence = 0.0,
    this.rationale,
  }) : _characters = characters;

  factory _$CenterPositionImpl.fromJson(Map<String, dynamic> json) =>
      _$$CenterPositionImplFromJson(json);

  @override
  final String label;
  final List<String> _characters;
  @override
  List<String> get characters {
    if (_characters is EqualUnmodifiableListView) return _characters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_characters);
  }

  @override
  final String summary;
  @override
  final String? details;
  @override
  @JsonKey()
  final double confidence;
  @override
  final DynamicsRationale? rationale;

  @override
  String toString() {
    return 'CenterPosition(label: $label, characters: $characters, summary: $summary, details: $details, confidence: $confidence, rationale: $rationale)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CenterPositionImpl &&
            (identical(other.label, label) || other.label == label) &&
            const DeepCollectionEquality().equals(
              other._characters,
              _characters,
            ) &&
            (identical(other.summary, summary) || other.summary == summary) &&
            (identical(other.details, details) || other.details == details) &&
            (identical(other.confidence, confidence) ||
                other.confidence == confidence) &&
            (identical(other.rationale, rationale) ||
                other.rationale == rationale));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    label,
    const DeepCollectionEquality().hash(_characters),
    summary,
    details,
    confidence,
    rationale,
  );

  /// Create a copy of CenterPosition
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CenterPositionImplCopyWith<_$CenterPositionImpl> get copyWith =>
      __$$CenterPositionImplCopyWithImpl<_$CenterPositionImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$CenterPositionImplToJson(this);
  }
}

abstract class _CenterPosition implements CenterPosition {
  const factory _CenterPosition({
    required final String label,
    required final List<String> characters,
    required final String summary,
    final String? details,
    final double confidence,
    final DynamicsRationale? rationale,
  }) = _$CenterPositionImpl;

  factory _CenterPosition.fromJson(Map<String, dynamic> json) =
      _$CenterPositionImpl.fromJson;

  @override
  String get label;
  @override
  List<String> get characters;
  @override
  String get summary;
  @override
  String? get details;
  @override
  double get confidence;
  @override
  DynamicsRationale? get rationale;

  /// Create a copy of CenterPosition
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CenterPositionImplCopyWith<_$CenterPositionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

OrbitEntry _$OrbitEntryFromJson(Map<String, dynamic> json) {
  return _OrbitEntry.fromJson(json);
}

/// @nodoc
mixin _$OrbitEntry {
  OrbitTrigger get trigger => throw _privateConstructorUsedError;
  List<String> get characters => throw _privateConstructorUsedError;
  String? get pattern => throw _privateConstructorUsedError;
  String? get costRisk => throw _privateConstructorUsedError;
  String? get stabilizer => throw _privateConstructorUsedError;
  DynamicsRationale? get rationale => throw _privateConstructorUsedError;

  /// Serializes this OrbitEntry to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of OrbitEntry
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OrbitEntryCopyWith<OrbitEntry> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrbitEntryCopyWith<$Res> {
  factory $OrbitEntryCopyWith(
    OrbitEntry value,
    $Res Function(OrbitEntry) then,
  ) = _$OrbitEntryCopyWithImpl<$Res, OrbitEntry>;
  @useResult
  $Res call({
    OrbitTrigger trigger,
    List<String> characters,
    String? pattern,
    String? costRisk,
    String? stabilizer,
    DynamicsRationale? rationale,
  });

  $OrbitTriggerCopyWith<$Res> get trigger;
  $DynamicsRationaleCopyWith<$Res>? get rationale;
}

/// @nodoc
class _$OrbitEntryCopyWithImpl<$Res, $Val extends OrbitEntry>
    implements $OrbitEntryCopyWith<$Res> {
  _$OrbitEntryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OrbitEntry
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? trigger = null,
    Object? characters = null,
    Object? pattern = freezed,
    Object? costRisk = freezed,
    Object? stabilizer = freezed,
    Object? rationale = freezed,
  }) {
    return _then(
      _value.copyWith(
            trigger: null == trigger
                ? _value.trigger
                : trigger // ignore: cast_nullable_to_non_nullable
                      as OrbitTrigger,
            characters: null == characters
                ? _value.characters
                : characters // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            pattern: freezed == pattern
                ? _value.pattern
                : pattern // ignore: cast_nullable_to_non_nullable
                      as String?,
            costRisk: freezed == costRisk
                ? _value.costRisk
                : costRisk // ignore: cast_nullable_to_non_nullable
                      as String?,
            stabilizer: freezed == stabilizer
                ? _value.stabilizer
                : stabilizer // ignore: cast_nullable_to_non_nullable
                      as String?,
            rationale: freezed == rationale
                ? _value.rationale
                : rationale // ignore: cast_nullable_to_non_nullable
                      as DynamicsRationale?,
          )
          as $Val,
    );
  }

  /// Create a copy of OrbitEntry
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OrbitTriggerCopyWith<$Res> get trigger {
    return $OrbitTriggerCopyWith<$Res>(_value.trigger, (value) {
      return _then(_value.copyWith(trigger: value) as $Val);
    });
  }

  /// Create a copy of OrbitEntry
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DynamicsRationaleCopyWith<$Res>? get rationale {
    if (_value.rationale == null) {
      return null;
    }

    return $DynamicsRationaleCopyWith<$Res>(_value.rationale!, (value) {
      return _then(_value.copyWith(rationale: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$OrbitEntryImplCopyWith<$Res>
    implements $OrbitEntryCopyWith<$Res> {
  factory _$$OrbitEntryImplCopyWith(
    _$OrbitEntryImpl value,
    $Res Function(_$OrbitEntryImpl) then,
  ) = __$$OrbitEntryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    OrbitTrigger trigger,
    List<String> characters,
    String? pattern,
    String? costRisk,
    String? stabilizer,
    DynamicsRationale? rationale,
  });

  @override
  $OrbitTriggerCopyWith<$Res> get trigger;
  @override
  $DynamicsRationaleCopyWith<$Res>? get rationale;
}

/// @nodoc
class __$$OrbitEntryImplCopyWithImpl<$Res>
    extends _$OrbitEntryCopyWithImpl<$Res, _$OrbitEntryImpl>
    implements _$$OrbitEntryImplCopyWith<$Res> {
  __$$OrbitEntryImplCopyWithImpl(
    _$OrbitEntryImpl _value,
    $Res Function(_$OrbitEntryImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of OrbitEntry
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? trigger = null,
    Object? characters = null,
    Object? pattern = freezed,
    Object? costRisk = freezed,
    Object? stabilizer = freezed,
    Object? rationale = freezed,
  }) {
    return _then(
      _$OrbitEntryImpl(
        trigger: null == trigger
            ? _value.trigger
            : trigger // ignore: cast_nullable_to_non_nullable
                  as OrbitTrigger,
        characters: null == characters
            ? _value._characters
            : characters // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        pattern: freezed == pattern
            ? _value.pattern
            : pattern // ignore: cast_nullable_to_non_nullable
                  as String?,
        costRisk: freezed == costRisk
            ? _value.costRisk
            : costRisk // ignore: cast_nullable_to_non_nullable
                  as String?,
        stabilizer: freezed == stabilizer
            ? _value.stabilizer
            : stabilizer // ignore: cast_nullable_to_non_nullable
                  as String?,
        rationale: freezed == rationale
            ? _value.rationale
            : rationale // ignore: cast_nullable_to_non_nullable
                  as DynamicsRationale?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$OrbitEntryImpl implements _OrbitEntry {
  const _$OrbitEntryImpl({
    required this.trigger,
    final List<String> characters = const [],
    this.pattern,
    this.costRisk,
    this.stabilizer,
    this.rationale,
  }) : _characters = characters;

  factory _$OrbitEntryImpl.fromJson(Map<String, dynamic> json) =>
      _$$OrbitEntryImplFromJson(json);

  @override
  final OrbitTrigger trigger;
  final List<String> _characters;
  @override
  @JsonKey()
  List<String> get characters {
    if (_characters is EqualUnmodifiableListView) return _characters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_characters);
  }

  @override
  final String? pattern;
  @override
  final String? costRisk;
  @override
  final String? stabilizer;
  @override
  final DynamicsRationale? rationale;

  @override
  String toString() {
    return 'OrbitEntry(trigger: $trigger, characters: $characters, pattern: $pattern, costRisk: $costRisk, stabilizer: $stabilizer, rationale: $rationale)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OrbitEntryImpl &&
            (identical(other.trigger, trigger) || other.trigger == trigger) &&
            const DeepCollectionEquality().equals(
              other._characters,
              _characters,
            ) &&
            (identical(other.pattern, pattern) || other.pattern == pattern) &&
            (identical(other.costRisk, costRisk) ||
                other.costRisk == costRisk) &&
            (identical(other.stabilizer, stabilizer) ||
                other.stabilizer == stabilizer) &&
            (identical(other.rationale, rationale) ||
                other.rationale == rationale));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    trigger,
    const DeepCollectionEquality().hash(_characters),
    pattern,
    costRisk,
    stabilizer,
    rationale,
  );

  /// Create a copy of OrbitEntry
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OrbitEntryImplCopyWith<_$OrbitEntryImpl> get copyWith =>
      __$$OrbitEntryImplCopyWithImpl<_$OrbitEntryImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OrbitEntryImplToJson(this);
  }
}

abstract class _OrbitEntry implements OrbitEntry {
  const factory _OrbitEntry({
    required final OrbitTrigger trigger,
    final List<String> characters,
    final String? pattern,
    final String? costRisk,
    final String? stabilizer,
    final DynamicsRationale? rationale,
  }) = _$OrbitEntryImpl;

  factory _OrbitEntry.fromJson(Map<String, dynamic> json) =
      _$OrbitEntryImpl.fromJson;

  @override
  OrbitTrigger get trigger;
  @override
  List<String> get characters;
  @override
  String? get pattern;
  @override
  String? get costRisk;
  @override
  String? get stabilizer;
  @override
  DynamicsRationale? get rationale;

  /// Create a copy of OrbitEntry
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OrbitEntryImplCopyWith<_$OrbitEntryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

OrbitTrigger _$OrbitTriggerFromJson(Map<String, dynamic> json) {
  return _OrbitTrigger.fromJson(json);
}

/// @nodoc
mixin _$OrbitTrigger {
  String get name => throw _privateConstructorUsedError;
  List<String> get tags => throw _privateConstructorUsedError;

  /// Serializes this OrbitTrigger to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of OrbitTrigger
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OrbitTriggerCopyWith<OrbitTrigger> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrbitTriggerCopyWith<$Res> {
  factory $OrbitTriggerCopyWith(
    OrbitTrigger value,
    $Res Function(OrbitTrigger) then,
  ) = _$OrbitTriggerCopyWithImpl<$Res, OrbitTrigger>;
  @useResult
  $Res call({String name, List<String> tags});
}

/// @nodoc
class _$OrbitTriggerCopyWithImpl<$Res, $Val extends OrbitTrigger>
    implements $OrbitTriggerCopyWith<$Res> {
  _$OrbitTriggerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OrbitTrigger
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? name = null, Object? tags = null}) {
    return _then(
      _value.copyWith(
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            tags: null == tags
                ? _value.tags
                : tags // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$OrbitTriggerImplCopyWith<$Res>
    implements $OrbitTriggerCopyWith<$Res> {
  factory _$$OrbitTriggerImplCopyWith(
    _$OrbitTriggerImpl value,
    $Res Function(_$OrbitTriggerImpl) then,
  ) = __$$OrbitTriggerImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, List<String> tags});
}

/// @nodoc
class __$$OrbitTriggerImplCopyWithImpl<$Res>
    extends _$OrbitTriggerCopyWithImpl<$Res, _$OrbitTriggerImpl>
    implements _$$OrbitTriggerImplCopyWith<$Res> {
  __$$OrbitTriggerImplCopyWithImpl(
    _$OrbitTriggerImpl _value,
    $Res Function(_$OrbitTriggerImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of OrbitTrigger
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? name = null, Object? tags = null}) {
    return _then(
      _$OrbitTriggerImpl(
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        tags: null == tags
            ? _value._tags
            : tags // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$OrbitTriggerImpl implements _OrbitTrigger {
  const _$OrbitTriggerImpl({
    required this.name,
    final List<String> tags = const [],
  }) : _tags = tags;

  factory _$OrbitTriggerImpl.fromJson(Map<String, dynamic> json) =>
      _$$OrbitTriggerImplFromJson(json);

  @override
  final String name;
  final List<String> _tags;
  @override
  @JsonKey()
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }

  @override
  String toString() {
    return 'OrbitTrigger(name: $name, tags: $tags)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OrbitTriggerImpl &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._tags, _tags));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    name,
    const DeepCollectionEquality().hash(_tags),
  );

  /// Create a copy of OrbitTrigger
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OrbitTriggerImplCopyWith<_$OrbitTriggerImpl> get copyWith =>
      __$$OrbitTriggerImplCopyWithImpl<_$OrbitTriggerImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OrbitTriggerImplToJson(this);
  }
}

abstract class _OrbitTrigger implements OrbitTrigger {
  const factory _OrbitTrigger({
    required final String name,
    final List<String> tags,
  }) = _$OrbitTriggerImpl;

  factory _OrbitTrigger.fromJson(Map<String, dynamic> json) =
      _$OrbitTriggerImpl.fromJson;

  @override
  String get name;
  @override
  List<String> get tags;

  /// Create a copy of OrbitTrigger
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OrbitTriggerImplCopyWith<_$OrbitTriggerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CompensationEntry _$CompensationEntryFromJson(Map<String, dynamic> json) {
  return _CompensationEntry.fromJson(json);
}

/// @nodoc
mixin _$CompensationEntry {
  String get name => throw _privateConstructorUsedError;
  String? get when => throw _privateConstructorUsedError;
  @StringOrListConverter()
  List<String> get expression => throw _privateConstructorUsedError;
  String? get risk => throw _privateConstructorUsedError;
  String? get returnPath => throw _privateConstructorUsedError;
  List<String> get characters => throw _privateConstructorUsedError;
  DynamicsRationale? get rationale => throw _privateConstructorUsedError;

  /// Serializes this CompensationEntry to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CompensationEntry
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CompensationEntryCopyWith<CompensationEntry> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompensationEntryCopyWith<$Res> {
  factory $CompensationEntryCopyWith(
    CompensationEntry value,
    $Res Function(CompensationEntry) then,
  ) = _$CompensationEntryCopyWithImpl<$Res, CompensationEntry>;
  @useResult
  $Res call({
    String name,
    String? when,
    @StringOrListConverter() List<String> expression,
    String? risk,
    String? returnPath,
    List<String> characters,
    DynamicsRationale? rationale,
  });

  $DynamicsRationaleCopyWith<$Res>? get rationale;
}

/// @nodoc
class _$CompensationEntryCopyWithImpl<$Res, $Val extends CompensationEntry>
    implements $CompensationEntryCopyWith<$Res> {
  _$CompensationEntryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CompensationEntry
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? when = freezed,
    Object? expression = null,
    Object? risk = freezed,
    Object? returnPath = freezed,
    Object? characters = null,
    Object? rationale = freezed,
  }) {
    return _then(
      _value.copyWith(
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
            when: freezed == when
                ? _value.when
                : when // ignore: cast_nullable_to_non_nullable
                      as String?,
            expression: null == expression
                ? _value.expression
                : expression // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            risk: freezed == risk
                ? _value.risk
                : risk // ignore: cast_nullable_to_non_nullable
                      as String?,
            returnPath: freezed == returnPath
                ? _value.returnPath
                : returnPath // ignore: cast_nullable_to_non_nullable
                      as String?,
            characters: null == characters
                ? _value.characters
                : characters // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            rationale: freezed == rationale
                ? _value.rationale
                : rationale // ignore: cast_nullable_to_non_nullable
                      as DynamicsRationale?,
          )
          as $Val,
    );
  }

  /// Create a copy of CompensationEntry
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DynamicsRationaleCopyWith<$Res>? get rationale {
    if (_value.rationale == null) {
      return null;
    }

    return $DynamicsRationaleCopyWith<$Res>(_value.rationale!, (value) {
      return _then(_value.copyWith(rationale: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CompensationEntryImplCopyWith<$Res>
    implements $CompensationEntryCopyWith<$Res> {
  factory _$$CompensationEntryImplCopyWith(
    _$CompensationEntryImpl value,
    $Res Function(_$CompensationEntryImpl) then,
  ) = __$$CompensationEntryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String name,
    String? when,
    @StringOrListConverter() List<String> expression,
    String? risk,
    String? returnPath,
    List<String> characters,
    DynamicsRationale? rationale,
  });

  @override
  $DynamicsRationaleCopyWith<$Res>? get rationale;
}

/// @nodoc
class __$$CompensationEntryImplCopyWithImpl<$Res>
    extends _$CompensationEntryCopyWithImpl<$Res, _$CompensationEntryImpl>
    implements _$$CompensationEntryImplCopyWith<$Res> {
  __$$CompensationEntryImplCopyWithImpl(
    _$CompensationEntryImpl _value,
    $Res Function(_$CompensationEntryImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of CompensationEntry
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? when = freezed,
    Object? expression = null,
    Object? risk = freezed,
    Object? returnPath = freezed,
    Object? characters = null,
    Object? rationale = freezed,
  }) {
    return _then(
      _$CompensationEntryImpl(
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
        when: freezed == when
            ? _value.when
            : when // ignore: cast_nullable_to_non_nullable
                  as String?,
        expression: null == expression
            ? _value._expression
            : expression // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        risk: freezed == risk
            ? _value.risk
            : risk // ignore: cast_nullable_to_non_nullable
                  as String?,
        returnPath: freezed == returnPath
            ? _value.returnPath
            : returnPath // ignore: cast_nullable_to_non_nullable
                  as String?,
        characters: null == characters
            ? _value._characters
            : characters // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        rationale: freezed == rationale
            ? _value.rationale
            : rationale // ignore: cast_nullable_to_non_nullable
                  as DynamicsRationale?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$CompensationEntryImpl implements _CompensationEntry {
  const _$CompensationEntryImpl({
    required this.name,
    this.when,
    @StringOrListConverter() final List<String> expression = const [],
    this.risk,
    this.returnPath,
    final List<String> characters = const [],
    this.rationale,
  }) : _expression = expression,
       _characters = characters;

  factory _$CompensationEntryImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompensationEntryImplFromJson(json);

  @override
  final String name;
  @override
  final String? when;
  final List<String> _expression;
  @override
  @JsonKey()
  @StringOrListConverter()
  List<String> get expression {
    if (_expression is EqualUnmodifiableListView) return _expression;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_expression);
  }

  @override
  final String? risk;
  @override
  final String? returnPath;
  final List<String> _characters;
  @override
  @JsonKey()
  List<String> get characters {
    if (_characters is EqualUnmodifiableListView) return _characters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_characters);
  }

  @override
  final DynamicsRationale? rationale;

  @override
  String toString() {
    return 'CompensationEntry(name: $name, when: $when, expression: $expression, risk: $risk, returnPath: $returnPath, characters: $characters, rationale: $rationale)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompensationEntryImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.when, when) || other.when == when) &&
            const DeepCollectionEquality().equals(
              other._expression,
              _expression,
            ) &&
            (identical(other.risk, risk) || other.risk == risk) &&
            (identical(other.returnPath, returnPath) ||
                other.returnPath == returnPath) &&
            const DeepCollectionEquality().equals(
              other._characters,
              _characters,
            ) &&
            (identical(other.rationale, rationale) ||
                other.rationale == rationale));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    name,
    when,
    const DeepCollectionEquality().hash(_expression),
    risk,
    returnPath,
    const DeepCollectionEquality().hash(_characters),
    rationale,
  );

  /// Create a copy of CompensationEntry
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CompensationEntryImplCopyWith<_$CompensationEntryImpl> get copyWith =>
      __$$CompensationEntryImplCopyWithImpl<_$CompensationEntryImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$CompensationEntryImplToJson(this);
  }
}

abstract class _CompensationEntry implements CompensationEntry {
  const factory _CompensationEntry({
    required final String name,
    final String? when,
    @StringOrListConverter() final List<String> expression,
    final String? risk,
    final String? returnPath,
    final List<String> characters,
    final DynamicsRationale? rationale,
  }) = _$CompensationEntryImpl;

  factory _CompensationEntry.fromJson(Map<String, dynamic> json) =
      _$CompensationEntryImpl.fromJson;

  @override
  String get name;
  @override
  String? get when;
  @override
  @StringOrListConverter()
  List<String> get expression;
  @override
  String? get risk;
  @override
  String? get returnPath;
  @override
  List<String> get characters;
  @override
  DynamicsRationale? get rationale;

  /// Create a copy of CompensationEntry
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CompensationEntryImplCopyWith<_$CompensationEntryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DynamicsRationale _$DynamicsRationaleFromJson(Map<String, dynamic> json) {
  return _DynamicsRationale.fromJson(json);
}

/// @nodoc
mixin _$DynamicsRationale {
  List<String> get traitSignals => throw _privateConstructorUsedError;
  List<String> get assessmentRefs => throw _privateConstructorUsedError;
  List<String> get exampleRefs => throw _privateConstructorUsedError;

  /// Serializes this DynamicsRationale to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of DynamicsRationale
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DynamicsRationaleCopyWith<DynamicsRationale> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DynamicsRationaleCopyWith<$Res> {
  factory $DynamicsRationaleCopyWith(
    DynamicsRationale value,
    $Res Function(DynamicsRationale) then,
  ) = _$DynamicsRationaleCopyWithImpl<$Res, DynamicsRationale>;
  @useResult
  $Res call({
    List<String> traitSignals,
    List<String> assessmentRefs,
    List<String> exampleRefs,
  });
}

/// @nodoc
class _$DynamicsRationaleCopyWithImpl<$Res, $Val extends DynamicsRationale>
    implements $DynamicsRationaleCopyWith<$Res> {
  _$DynamicsRationaleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DynamicsRationale
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? traitSignals = null,
    Object? assessmentRefs = null,
    Object? exampleRefs = null,
  }) {
    return _then(
      _value.copyWith(
            traitSignals: null == traitSignals
                ? _value.traitSignals
                : traitSignals // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            assessmentRefs: null == assessmentRefs
                ? _value.assessmentRefs
                : assessmentRefs // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            exampleRefs: null == exampleRefs
                ? _value.exampleRefs
                : exampleRefs // ignore: cast_nullable_to_non_nullable
                      as List<String>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$DynamicsRationaleImplCopyWith<$Res>
    implements $DynamicsRationaleCopyWith<$Res> {
  factory _$$DynamicsRationaleImplCopyWith(
    _$DynamicsRationaleImpl value,
    $Res Function(_$DynamicsRationaleImpl) then,
  ) = __$$DynamicsRationaleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    List<String> traitSignals,
    List<String> assessmentRefs,
    List<String> exampleRefs,
  });
}

/// @nodoc
class __$$DynamicsRationaleImplCopyWithImpl<$Res>
    extends _$DynamicsRationaleCopyWithImpl<$Res, _$DynamicsRationaleImpl>
    implements _$$DynamicsRationaleImplCopyWith<$Res> {
  __$$DynamicsRationaleImplCopyWithImpl(
    _$DynamicsRationaleImpl _value,
    $Res Function(_$DynamicsRationaleImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DynamicsRationale
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? traitSignals = null,
    Object? assessmentRefs = null,
    Object? exampleRefs = null,
  }) {
    return _then(
      _$DynamicsRationaleImpl(
        traitSignals: null == traitSignals
            ? _value._traitSignals
            : traitSignals // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        assessmentRefs: null == assessmentRefs
            ? _value._assessmentRefs
            : assessmentRefs // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        exampleRefs: null == exampleRefs
            ? _value._exampleRefs
            : exampleRefs // ignore: cast_nullable_to_non_nullable
                  as List<String>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$DynamicsRationaleImpl implements _DynamicsRationale {
  const _$DynamicsRationaleImpl({
    final List<String> traitSignals = const [],
    final List<String> assessmentRefs = const [],
    final List<String> exampleRefs = const [],
  }) : _traitSignals = traitSignals,
       _assessmentRefs = assessmentRefs,
       _exampleRefs = exampleRefs;

  factory _$DynamicsRationaleImpl.fromJson(Map<String, dynamic> json) =>
      _$$DynamicsRationaleImplFromJson(json);

  final List<String> _traitSignals;
  @override
  @JsonKey()
  List<String> get traitSignals {
    if (_traitSignals is EqualUnmodifiableListView) return _traitSignals;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_traitSignals);
  }

  final List<String> _assessmentRefs;
  @override
  @JsonKey()
  List<String> get assessmentRefs {
    if (_assessmentRefs is EqualUnmodifiableListView) return _assessmentRefs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_assessmentRefs);
  }

  final List<String> _exampleRefs;
  @override
  @JsonKey()
  List<String> get exampleRefs {
    if (_exampleRefs is EqualUnmodifiableListView) return _exampleRefs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_exampleRefs);
  }

  @override
  String toString() {
    return 'DynamicsRationale(traitSignals: $traitSignals, assessmentRefs: $assessmentRefs, exampleRefs: $exampleRefs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DynamicsRationaleImpl &&
            const DeepCollectionEquality().equals(
              other._traitSignals,
              _traitSignals,
            ) &&
            const DeepCollectionEquality().equals(
              other._assessmentRefs,
              _assessmentRefs,
            ) &&
            const DeepCollectionEquality().equals(
              other._exampleRefs,
              _exampleRefs,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    const DeepCollectionEquality().hash(_traitSignals),
    const DeepCollectionEquality().hash(_assessmentRefs),
    const DeepCollectionEquality().hash(_exampleRefs),
  );

  /// Create a copy of DynamicsRationale
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DynamicsRationaleImplCopyWith<_$DynamicsRationaleImpl> get copyWith =>
      __$$DynamicsRationaleImplCopyWithImpl<_$DynamicsRationaleImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$DynamicsRationaleImplToJson(this);
  }
}

abstract class _DynamicsRationale implements DynamicsRationale {
  const factory _DynamicsRationale({
    final List<String> traitSignals,
    final List<String> assessmentRefs,
    final List<String> exampleRefs,
  }) = _$DynamicsRationaleImpl;

  factory _DynamicsRationale.fromJson(Map<String, dynamic> json) =
      _$DynamicsRationaleImpl.fromJson;

  @override
  List<String> get traitSignals;
  @override
  List<String> get assessmentRefs;
  @override
  List<String> get exampleRefs;

  /// Create a copy of DynamicsRationale
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DynamicsRationaleImplCopyWith<_$DynamicsRationaleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ExamplesOutput _$ExamplesOutputFromJson(Map<String, dynamic> json) {
  return _ExamplesOutput.fromJson(json);
}

/// @nodoc
mixin _$ExamplesOutput {
  @StoryExamplesConverter()
  StoryExamples get story => throw _privateConstructorUsedError;
  IdentificationExamples? get identification =>
      throw _privateConstructorUsedError;
  @FunctioningExamplesConverter()
  FunctioningExamples get functioning => throw _privateConstructorUsedError;
  List<ExampleItem> get actions => throw _privateConstructorUsedError;
  LifeDomainsExamples? get lifeDomains => throw _privateConstructorUsedError;

  /// Serializes this ExamplesOutput to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ExamplesOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ExamplesOutputCopyWith<ExamplesOutput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExamplesOutputCopyWith<$Res> {
  factory $ExamplesOutputCopyWith(
    ExamplesOutput value,
    $Res Function(ExamplesOutput) then,
  ) = _$ExamplesOutputCopyWithImpl<$Res, ExamplesOutput>;
  @useResult
  $Res call({
    @StoryExamplesConverter() StoryExamples story,
    IdentificationExamples? identification,
    @FunctioningExamplesConverter() FunctioningExamples functioning,
    List<ExampleItem> actions,
    LifeDomainsExamples? lifeDomains,
  });

  $StoryExamplesCopyWith<$Res> get story;
  $IdentificationExamplesCopyWith<$Res>? get identification;
  $FunctioningExamplesCopyWith<$Res> get functioning;
  $LifeDomainsExamplesCopyWith<$Res>? get lifeDomains;
}

/// @nodoc
class _$ExamplesOutputCopyWithImpl<$Res, $Val extends ExamplesOutput>
    implements $ExamplesOutputCopyWith<$Res> {
  _$ExamplesOutputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ExamplesOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? story = null,
    Object? identification = freezed,
    Object? functioning = null,
    Object? actions = null,
    Object? lifeDomains = freezed,
  }) {
    return _then(
      _value.copyWith(
            story: null == story
                ? _value.story
                : story // ignore: cast_nullable_to_non_nullable
                      as StoryExamples,
            identification: freezed == identification
                ? _value.identification
                : identification // ignore: cast_nullable_to_non_nullable
                      as IdentificationExamples?,
            functioning: null == functioning
                ? _value.functioning
                : functioning // ignore: cast_nullable_to_non_nullable
                      as FunctioningExamples,
            actions: null == actions
                ? _value.actions
                : actions // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            lifeDomains: freezed == lifeDomains
                ? _value.lifeDomains
                : lifeDomains // ignore: cast_nullable_to_non_nullable
                      as LifeDomainsExamples?,
          )
          as $Val,
    );
  }

  /// Create a copy of ExamplesOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StoryExamplesCopyWith<$Res> get story {
    return $StoryExamplesCopyWith<$Res>(_value.story, (value) {
      return _then(_value.copyWith(story: value) as $Val);
    });
  }

  /// Create a copy of ExamplesOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $IdentificationExamplesCopyWith<$Res>? get identification {
    if (_value.identification == null) {
      return null;
    }

    return $IdentificationExamplesCopyWith<$Res>(_value.identification!, (
      value,
    ) {
      return _then(_value.copyWith(identification: value) as $Val);
    });
  }

  /// Create a copy of ExamplesOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FunctioningExamplesCopyWith<$Res> get functioning {
    return $FunctioningExamplesCopyWith<$Res>(_value.functioning, (value) {
      return _then(_value.copyWith(functioning: value) as $Val);
    });
  }

  /// Create a copy of ExamplesOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LifeDomainsExamplesCopyWith<$Res>? get lifeDomains {
    if (_value.lifeDomains == null) {
      return null;
    }

    return $LifeDomainsExamplesCopyWith<$Res>(_value.lifeDomains!, (value) {
      return _then(_value.copyWith(lifeDomains: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExamplesOutputImplCopyWith<$Res>
    implements $ExamplesOutputCopyWith<$Res> {
  factory _$$ExamplesOutputImplCopyWith(
    _$ExamplesOutputImpl value,
    $Res Function(_$ExamplesOutputImpl) then,
  ) = __$$ExamplesOutputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    @StoryExamplesConverter() StoryExamples story,
    IdentificationExamples? identification,
    @FunctioningExamplesConverter() FunctioningExamples functioning,
    List<ExampleItem> actions,
    LifeDomainsExamples? lifeDomains,
  });

  @override
  $StoryExamplesCopyWith<$Res> get story;
  @override
  $IdentificationExamplesCopyWith<$Res>? get identification;
  @override
  $FunctioningExamplesCopyWith<$Res> get functioning;
  @override
  $LifeDomainsExamplesCopyWith<$Res>? get lifeDomains;
}

/// @nodoc
class __$$ExamplesOutputImplCopyWithImpl<$Res>
    extends _$ExamplesOutputCopyWithImpl<$Res, _$ExamplesOutputImpl>
    implements _$$ExamplesOutputImplCopyWith<$Res> {
  __$$ExamplesOutputImplCopyWithImpl(
    _$ExamplesOutputImpl _value,
    $Res Function(_$ExamplesOutputImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ExamplesOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? story = null,
    Object? identification = freezed,
    Object? functioning = null,
    Object? actions = null,
    Object? lifeDomains = freezed,
  }) {
    return _then(
      _$ExamplesOutputImpl(
        story: null == story
            ? _value.story
            : story // ignore: cast_nullable_to_non_nullable
                  as StoryExamples,
        identification: freezed == identification
            ? _value.identification
            : identification // ignore: cast_nullable_to_non_nullable
                  as IdentificationExamples?,
        functioning: null == functioning
            ? _value.functioning
            : functioning // ignore: cast_nullable_to_non_nullable
                  as FunctioningExamples,
        actions: null == actions
            ? _value._actions
            : actions // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        lifeDomains: freezed == lifeDomains
            ? _value.lifeDomains
            : lifeDomains // ignore: cast_nullable_to_non_nullable
                  as LifeDomainsExamples?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ExamplesOutputImpl implements _ExamplesOutput {
  const _$ExamplesOutputImpl({
    @StoryExamplesConverter() this.story = const StoryExamples(),
    this.identification,
    @FunctioningExamplesConverter()
    this.functioning = const FunctioningExamples(),
    final List<ExampleItem> actions = const [],
    this.lifeDomains,
  }) : _actions = actions;

  factory _$ExamplesOutputImpl.fromJson(Map<String, dynamic> json) =>
      _$$ExamplesOutputImplFromJson(json);

  @override
  @JsonKey()
  @StoryExamplesConverter()
  final StoryExamples story;
  @override
  final IdentificationExamples? identification;
  @override
  @JsonKey()
  @FunctioningExamplesConverter()
  final FunctioningExamples functioning;
  final List<ExampleItem> _actions;
  @override
  @JsonKey()
  List<ExampleItem> get actions {
    if (_actions is EqualUnmodifiableListView) return _actions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_actions);
  }

  @override
  final LifeDomainsExamples? lifeDomains;

  @override
  String toString() {
    return 'ExamplesOutput(story: $story, identification: $identification, functioning: $functioning, actions: $actions, lifeDomains: $lifeDomains)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExamplesOutputImpl &&
            (identical(other.story, story) || other.story == story) &&
            (identical(other.identification, identification) ||
                other.identification == identification) &&
            (identical(other.functioning, functioning) ||
                other.functioning == functioning) &&
            const DeepCollectionEquality().equals(other._actions, _actions) &&
            (identical(other.lifeDomains, lifeDomains) ||
                other.lifeDomains == lifeDomains));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    story,
    identification,
    functioning,
    const DeepCollectionEquality().hash(_actions),
    lifeDomains,
  );

  /// Create a copy of ExamplesOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExamplesOutputImplCopyWith<_$ExamplesOutputImpl> get copyWith =>
      __$$ExamplesOutputImplCopyWithImpl<_$ExamplesOutputImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$ExamplesOutputImplToJson(this);
  }
}

abstract class _ExamplesOutput implements ExamplesOutput {
  const factory _ExamplesOutput({
    @StoryExamplesConverter() final StoryExamples story,
    final IdentificationExamples? identification,
    @FunctioningExamplesConverter() final FunctioningExamples functioning,
    final List<ExampleItem> actions,
    final LifeDomainsExamples? lifeDomains,
  }) = _$ExamplesOutputImpl;

  factory _ExamplesOutput.fromJson(Map<String, dynamic> json) =
      _$ExamplesOutputImpl.fromJson;

  @override
  @StoryExamplesConverter()
  StoryExamples get story;
  @override
  IdentificationExamples? get identification;
  @override
  @FunctioningExamplesConverter()
  FunctioningExamples get functioning;
  @override
  List<ExampleItem> get actions;
  @override
  LifeDomainsExamples? get lifeDomains;

  /// Create a copy of ExamplesOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExamplesOutputImplCopyWith<_$ExamplesOutputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

StoryExamples _$StoryExamplesFromJson(Map<String, dynamic> json) {
  return _StoryExamples.fromJson(json);
}

/// @nodoc
mixin _$StoryExamples {
  List<ExampleItem> get mythSummary => throw _privateConstructorUsedError;
  List<ExampleItem> get centralTension => throw _privateConstructorUsedError;
  List<ExampleItem> get guidingSentence => throw _privateConstructorUsedError;
  List<ExampleItem> get northStarScene => throw _privateConstructorUsedError;

  /// Serializes this StoryExamples to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of StoryExamples
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StoryExamplesCopyWith<StoryExamples> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StoryExamplesCopyWith<$Res> {
  factory $StoryExamplesCopyWith(
    StoryExamples value,
    $Res Function(StoryExamples) then,
  ) = _$StoryExamplesCopyWithImpl<$Res, StoryExamples>;
  @useResult
  $Res call({
    List<ExampleItem> mythSummary,
    List<ExampleItem> centralTension,
    List<ExampleItem> guidingSentence,
    List<ExampleItem> northStarScene,
  });
}

/// @nodoc
class _$StoryExamplesCopyWithImpl<$Res, $Val extends StoryExamples>
    implements $StoryExamplesCopyWith<$Res> {
  _$StoryExamplesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StoryExamples
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mythSummary = null,
    Object? centralTension = null,
    Object? guidingSentence = null,
    Object? northStarScene = null,
  }) {
    return _then(
      _value.copyWith(
            mythSummary: null == mythSummary
                ? _value.mythSummary
                : mythSummary // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            centralTension: null == centralTension
                ? _value.centralTension
                : centralTension // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            guidingSentence: null == guidingSentence
                ? _value.guidingSentence
                : guidingSentence // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            northStarScene: null == northStarScene
                ? _value.northStarScene
                : northStarScene // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$StoryExamplesImplCopyWith<$Res>
    implements $StoryExamplesCopyWith<$Res> {
  factory _$$StoryExamplesImplCopyWith(
    _$StoryExamplesImpl value,
    $Res Function(_$StoryExamplesImpl) then,
  ) = __$$StoryExamplesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    List<ExampleItem> mythSummary,
    List<ExampleItem> centralTension,
    List<ExampleItem> guidingSentence,
    List<ExampleItem> northStarScene,
  });
}

/// @nodoc
class __$$StoryExamplesImplCopyWithImpl<$Res>
    extends _$StoryExamplesCopyWithImpl<$Res, _$StoryExamplesImpl>
    implements _$$StoryExamplesImplCopyWith<$Res> {
  __$$StoryExamplesImplCopyWithImpl(
    _$StoryExamplesImpl _value,
    $Res Function(_$StoryExamplesImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of StoryExamples
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mythSummary = null,
    Object? centralTension = null,
    Object? guidingSentence = null,
    Object? northStarScene = null,
  }) {
    return _then(
      _$StoryExamplesImpl(
        mythSummary: null == mythSummary
            ? _value._mythSummary
            : mythSummary // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        centralTension: null == centralTension
            ? _value._centralTension
            : centralTension // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        guidingSentence: null == guidingSentence
            ? _value._guidingSentence
            : guidingSentence // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        northStarScene: null == northStarScene
            ? _value._northStarScene
            : northStarScene // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$StoryExamplesImpl implements _StoryExamples {
  const _$StoryExamplesImpl({
    final List<ExampleItem> mythSummary = const [],
    final List<ExampleItem> centralTension = const [],
    final List<ExampleItem> guidingSentence = const [],
    final List<ExampleItem> northStarScene = const [],
  }) : _mythSummary = mythSummary,
       _centralTension = centralTension,
       _guidingSentence = guidingSentence,
       _northStarScene = northStarScene;

  factory _$StoryExamplesImpl.fromJson(Map<String, dynamic> json) =>
      _$$StoryExamplesImplFromJson(json);

  final List<ExampleItem> _mythSummary;
  @override
  @JsonKey()
  List<ExampleItem> get mythSummary {
    if (_mythSummary is EqualUnmodifiableListView) return _mythSummary;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_mythSummary);
  }

  final List<ExampleItem> _centralTension;
  @override
  @JsonKey()
  List<ExampleItem> get centralTension {
    if (_centralTension is EqualUnmodifiableListView) return _centralTension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_centralTension);
  }

  final List<ExampleItem> _guidingSentence;
  @override
  @JsonKey()
  List<ExampleItem> get guidingSentence {
    if (_guidingSentence is EqualUnmodifiableListView) return _guidingSentence;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_guidingSentence);
  }

  final List<ExampleItem> _northStarScene;
  @override
  @JsonKey()
  List<ExampleItem> get northStarScene {
    if (_northStarScene is EqualUnmodifiableListView) return _northStarScene;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_northStarScene);
  }

  @override
  String toString() {
    return 'StoryExamples(mythSummary: $mythSummary, centralTension: $centralTension, guidingSentence: $guidingSentence, northStarScene: $northStarScene)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StoryExamplesImpl &&
            const DeepCollectionEquality().equals(
              other._mythSummary,
              _mythSummary,
            ) &&
            const DeepCollectionEquality().equals(
              other._centralTension,
              _centralTension,
            ) &&
            const DeepCollectionEquality().equals(
              other._guidingSentence,
              _guidingSentence,
            ) &&
            const DeepCollectionEquality().equals(
              other._northStarScene,
              _northStarScene,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    const DeepCollectionEquality().hash(_mythSummary),
    const DeepCollectionEquality().hash(_centralTension),
    const DeepCollectionEquality().hash(_guidingSentence),
    const DeepCollectionEquality().hash(_northStarScene),
  );

  /// Create a copy of StoryExamples
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StoryExamplesImplCopyWith<_$StoryExamplesImpl> get copyWith =>
      __$$StoryExamplesImplCopyWithImpl<_$StoryExamplesImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StoryExamplesImplToJson(this);
  }
}

abstract class _StoryExamples implements StoryExamples {
  const factory _StoryExamples({
    final List<ExampleItem> mythSummary,
    final List<ExampleItem> centralTension,
    final List<ExampleItem> guidingSentence,
    final List<ExampleItem> northStarScene,
  }) = _$StoryExamplesImpl;

  factory _StoryExamples.fromJson(Map<String, dynamic> json) =
      _$StoryExamplesImpl.fromJson;

  @override
  List<ExampleItem> get mythSummary;
  @override
  List<ExampleItem> get centralTension;
  @override
  List<ExampleItem> get guidingSentence;
  @override
  List<ExampleItem> get northStarScene;

  /// Create a copy of StoryExamples
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StoryExamplesImplCopyWith<_$StoryExamplesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FunctioningExamples _$FunctioningExamplesFromJson(Map<String, dynamic> json) {
  return _FunctioningExamples.fromJson(json);
}

/// @nodoc
mixin _$FunctioningExamples {
  List<ExampleItem> get coreTraits => throw _privateConstructorUsedError;
  List<ExampleItem> get symbolicEssence => throw _privateConstructorUsedError;
  List<ExampleItem> get narrativeArc => throw _privateConstructorUsedError;
  List<ExampleItem> get redemptionArc => throw _privateConstructorUsedError;
  List<ExampleItem> get costsAndCompensations =>
      throw _privateConstructorUsedError;
  List<ExampleItem> get alignmentIndicators =>
      throw _privateConstructorUsedError;

  /// Serializes this FunctioningExamples to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of FunctioningExamples
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FunctioningExamplesCopyWith<FunctioningExamples> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FunctioningExamplesCopyWith<$Res> {
  factory $FunctioningExamplesCopyWith(
    FunctioningExamples value,
    $Res Function(FunctioningExamples) then,
  ) = _$FunctioningExamplesCopyWithImpl<$Res, FunctioningExamples>;
  @useResult
  $Res call({
    List<ExampleItem> coreTraits,
    List<ExampleItem> symbolicEssence,
    List<ExampleItem> narrativeArc,
    List<ExampleItem> redemptionArc,
    List<ExampleItem> costsAndCompensations,
    List<ExampleItem> alignmentIndicators,
  });
}

/// @nodoc
class _$FunctioningExamplesCopyWithImpl<$Res, $Val extends FunctioningExamples>
    implements $FunctioningExamplesCopyWith<$Res> {
  _$FunctioningExamplesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FunctioningExamples
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coreTraits = null,
    Object? symbolicEssence = null,
    Object? narrativeArc = null,
    Object? redemptionArc = null,
    Object? costsAndCompensations = null,
    Object? alignmentIndicators = null,
  }) {
    return _then(
      _value.copyWith(
            coreTraits: null == coreTraits
                ? _value.coreTraits
                : coreTraits // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            symbolicEssence: null == symbolicEssence
                ? _value.symbolicEssence
                : symbolicEssence // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            narrativeArc: null == narrativeArc
                ? _value.narrativeArc
                : narrativeArc // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            redemptionArc: null == redemptionArc
                ? _value.redemptionArc
                : redemptionArc // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            costsAndCompensations: null == costsAndCompensations
                ? _value.costsAndCompensations
                : costsAndCompensations // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            alignmentIndicators: null == alignmentIndicators
                ? _value.alignmentIndicators
                : alignmentIndicators // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$FunctioningExamplesImplCopyWith<$Res>
    implements $FunctioningExamplesCopyWith<$Res> {
  factory _$$FunctioningExamplesImplCopyWith(
    _$FunctioningExamplesImpl value,
    $Res Function(_$FunctioningExamplesImpl) then,
  ) = __$$FunctioningExamplesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    List<ExampleItem> coreTraits,
    List<ExampleItem> symbolicEssence,
    List<ExampleItem> narrativeArc,
    List<ExampleItem> redemptionArc,
    List<ExampleItem> costsAndCompensations,
    List<ExampleItem> alignmentIndicators,
  });
}

/// @nodoc
class __$$FunctioningExamplesImplCopyWithImpl<$Res>
    extends _$FunctioningExamplesCopyWithImpl<$Res, _$FunctioningExamplesImpl>
    implements _$$FunctioningExamplesImplCopyWith<$Res> {
  __$$FunctioningExamplesImplCopyWithImpl(
    _$FunctioningExamplesImpl _value,
    $Res Function(_$FunctioningExamplesImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of FunctioningExamples
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coreTraits = null,
    Object? symbolicEssence = null,
    Object? narrativeArc = null,
    Object? redemptionArc = null,
    Object? costsAndCompensations = null,
    Object? alignmentIndicators = null,
  }) {
    return _then(
      _$FunctioningExamplesImpl(
        coreTraits: null == coreTraits
            ? _value._coreTraits
            : coreTraits // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        symbolicEssence: null == symbolicEssence
            ? _value._symbolicEssence
            : symbolicEssence // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        narrativeArc: null == narrativeArc
            ? _value._narrativeArc
            : narrativeArc // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        redemptionArc: null == redemptionArc
            ? _value._redemptionArc
            : redemptionArc // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        costsAndCompensations: null == costsAndCompensations
            ? _value._costsAndCompensations
            : costsAndCompensations // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        alignmentIndicators: null == alignmentIndicators
            ? _value._alignmentIndicators
            : alignmentIndicators // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$FunctioningExamplesImpl implements _FunctioningExamples {
  const _$FunctioningExamplesImpl({
    final List<ExampleItem> coreTraits = const [],
    final List<ExampleItem> symbolicEssence = const [],
    final List<ExampleItem> narrativeArc = const [],
    final List<ExampleItem> redemptionArc = const [],
    final List<ExampleItem> costsAndCompensations = const [],
    final List<ExampleItem> alignmentIndicators = const [],
  }) : _coreTraits = coreTraits,
       _symbolicEssence = symbolicEssence,
       _narrativeArc = narrativeArc,
       _redemptionArc = redemptionArc,
       _costsAndCompensations = costsAndCompensations,
       _alignmentIndicators = alignmentIndicators;

  factory _$FunctioningExamplesImpl.fromJson(Map<String, dynamic> json) =>
      _$$FunctioningExamplesImplFromJson(json);

  final List<ExampleItem> _coreTraits;
  @override
  @JsonKey()
  List<ExampleItem> get coreTraits {
    if (_coreTraits is EqualUnmodifiableListView) return _coreTraits;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_coreTraits);
  }

  final List<ExampleItem> _symbolicEssence;
  @override
  @JsonKey()
  List<ExampleItem> get symbolicEssence {
    if (_symbolicEssence is EqualUnmodifiableListView) return _symbolicEssence;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_symbolicEssence);
  }

  final List<ExampleItem> _narrativeArc;
  @override
  @JsonKey()
  List<ExampleItem> get narrativeArc {
    if (_narrativeArc is EqualUnmodifiableListView) return _narrativeArc;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_narrativeArc);
  }

  final List<ExampleItem> _redemptionArc;
  @override
  @JsonKey()
  List<ExampleItem> get redemptionArc {
    if (_redemptionArc is EqualUnmodifiableListView) return _redemptionArc;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_redemptionArc);
  }

  final List<ExampleItem> _costsAndCompensations;
  @override
  @JsonKey()
  List<ExampleItem> get costsAndCompensations {
    if (_costsAndCompensations is EqualUnmodifiableListView)
      return _costsAndCompensations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_costsAndCompensations);
  }

  final List<ExampleItem> _alignmentIndicators;
  @override
  @JsonKey()
  List<ExampleItem> get alignmentIndicators {
    if (_alignmentIndicators is EqualUnmodifiableListView)
      return _alignmentIndicators;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_alignmentIndicators);
  }

  @override
  String toString() {
    return 'FunctioningExamples(coreTraits: $coreTraits, symbolicEssence: $symbolicEssence, narrativeArc: $narrativeArc, redemptionArc: $redemptionArc, costsAndCompensations: $costsAndCompensations, alignmentIndicators: $alignmentIndicators)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FunctioningExamplesImpl &&
            const DeepCollectionEquality().equals(
              other._coreTraits,
              _coreTraits,
            ) &&
            const DeepCollectionEquality().equals(
              other._symbolicEssence,
              _symbolicEssence,
            ) &&
            const DeepCollectionEquality().equals(
              other._narrativeArc,
              _narrativeArc,
            ) &&
            const DeepCollectionEquality().equals(
              other._redemptionArc,
              _redemptionArc,
            ) &&
            const DeepCollectionEquality().equals(
              other._costsAndCompensations,
              _costsAndCompensations,
            ) &&
            const DeepCollectionEquality().equals(
              other._alignmentIndicators,
              _alignmentIndicators,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    const DeepCollectionEquality().hash(_coreTraits),
    const DeepCollectionEquality().hash(_symbolicEssence),
    const DeepCollectionEquality().hash(_narrativeArc),
    const DeepCollectionEquality().hash(_redemptionArc),
    const DeepCollectionEquality().hash(_costsAndCompensations),
    const DeepCollectionEquality().hash(_alignmentIndicators),
  );

  /// Create a copy of FunctioningExamples
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FunctioningExamplesImplCopyWith<_$FunctioningExamplesImpl> get copyWith =>
      __$$FunctioningExamplesImplCopyWithImpl<_$FunctioningExamplesImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$FunctioningExamplesImplToJson(this);
  }
}

abstract class _FunctioningExamples implements FunctioningExamples {
  const factory _FunctioningExamples({
    final List<ExampleItem> coreTraits,
    final List<ExampleItem> symbolicEssence,
    final List<ExampleItem> narrativeArc,
    final List<ExampleItem> redemptionArc,
    final List<ExampleItem> costsAndCompensations,
    final List<ExampleItem> alignmentIndicators,
  }) = _$FunctioningExamplesImpl;

  factory _FunctioningExamples.fromJson(Map<String, dynamic> json) =
      _$FunctioningExamplesImpl.fromJson;

  @override
  List<ExampleItem> get coreTraits;
  @override
  List<ExampleItem> get symbolicEssence;
  @override
  List<ExampleItem> get narrativeArc;
  @override
  List<ExampleItem> get redemptionArc;
  @override
  List<ExampleItem> get costsAndCompensations;
  @override
  List<ExampleItem> get alignmentIndicators;

  /// Create a copy of FunctioningExamples
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FunctioningExamplesImplCopyWith<_$FunctioningExamplesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

IdentificationExamples _$IdentificationExamplesFromJson(
  Map<String, dynamic> json,
) {
  return _IdentificationExamples.fromJson(json);
}

/// @nodoc
mixin _$IdentificationExamples {
  List<ExampleItem> get ego => throw _privateConstructorUsedError;
  List<ExampleItem> get persona => throw _privateConstructorUsedError;
  List<ExampleItem> get shadow => throw _privateConstructorUsedError;
  List<ExampleItem> get shadowVirtue => throw _privateConstructorUsedError;
  List<ExampleItem> get feelingFunction => throw _privateConstructorUsedError;
  List<ExampleItem> get erosAxis => throw _privateConstructorUsedError;

  /// Serializes this IdentificationExamples to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of IdentificationExamples
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $IdentificationExamplesCopyWith<IdentificationExamples> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IdentificationExamplesCopyWith<$Res> {
  factory $IdentificationExamplesCopyWith(
    IdentificationExamples value,
    $Res Function(IdentificationExamples) then,
  ) = _$IdentificationExamplesCopyWithImpl<$Res, IdentificationExamples>;
  @useResult
  $Res call({
    List<ExampleItem> ego,
    List<ExampleItem> persona,
    List<ExampleItem> shadow,
    List<ExampleItem> shadowVirtue,
    List<ExampleItem> feelingFunction,
    List<ExampleItem> erosAxis,
  });
}

/// @nodoc
class _$IdentificationExamplesCopyWithImpl<
  $Res,
  $Val extends IdentificationExamples
>
    implements $IdentificationExamplesCopyWith<$Res> {
  _$IdentificationExamplesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of IdentificationExamples
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ego = null,
    Object? persona = null,
    Object? shadow = null,
    Object? shadowVirtue = null,
    Object? feelingFunction = null,
    Object? erosAxis = null,
  }) {
    return _then(
      _value.copyWith(
            ego: null == ego
                ? _value.ego
                : ego // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            persona: null == persona
                ? _value.persona
                : persona // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            shadow: null == shadow
                ? _value.shadow
                : shadow // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            shadowVirtue: null == shadowVirtue
                ? _value.shadowVirtue
                : shadowVirtue // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            feelingFunction: null == feelingFunction
                ? _value.feelingFunction
                : feelingFunction // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            erosAxis: null == erosAxis
                ? _value.erosAxis
                : erosAxis // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$IdentificationExamplesImplCopyWith<$Res>
    implements $IdentificationExamplesCopyWith<$Res> {
  factory _$$IdentificationExamplesImplCopyWith(
    _$IdentificationExamplesImpl value,
    $Res Function(_$IdentificationExamplesImpl) then,
  ) = __$$IdentificationExamplesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    List<ExampleItem> ego,
    List<ExampleItem> persona,
    List<ExampleItem> shadow,
    List<ExampleItem> shadowVirtue,
    List<ExampleItem> feelingFunction,
    List<ExampleItem> erosAxis,
  });
}

/// @nodoc
class __$$IdentificationExamplesImplCopyWithImpl<$Res>
    extends
        _$IdentificationExamplesCopyWithImpl<$Res, _$IdentificationExamplesImpl>
    implements _$$IdentificationExamplesImplCopyWith<$Res> {
  __$$IdentificationExamplesImplCopyWithImpl(
    _$IdentificationExamplesImpl _value,
    $Res Function(_$IdentificationExamplesImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of IdentificationExamples
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ego = null,
    Object? persona = null,
    Object? shadow = null,
    Object? shadowVirtue = null,
    Object? feelingFunction = null,
    Object? erosAxis = null,
  }) {
    return _then(
      _$IdentificationExamplesImpl(
        ego: null == ego
            ? _value._ego
            : ego // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        persona: null == persona
            ? _value._persona
            : persona // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        shadow: null == shadow
            ? _value._shadow
            : shadow // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        shadowVirtue: null == shadowVirtue
            ? _value._shadowVirtue
            : shadowVirtue // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        feelingFunction: null == feelingFunction
            ? _value._feelingFunction
            : feelingFunction // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        erosAxis: null == erosAxis
            ? _value._erosAxis
            : erosAxis // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$IdentificationExamplesImpl implements _IdentificationExamples {
  const _$IdentificationExamplesImpl({
    final List<ExampleItem> ego = const [],
    final List<ExampleItem> persona = const [],
    final List<ExampleItem> shadow = const [],
    final List<ExampleItem> shadowVirtue = const [],
    final List<ExampleItem> feelingFunction = const [],
    final List<ExampleItem> erosAxis = const [],
  }) : _ego = ego,
       _persona = persona,
       _shadow = shadow,
       _shadowVirtue = shadowVirtue,
       _feelingFunction = feelingFunction,
       _erosAxis = erosAxis;

  factory _$IdentificationExamplesImpl.fromJson(Map<String, dynamic> json) =>
      _$$IdentificationExamplesImplFromJson(json);

  final List<ExampleItem> _ego;
  @override
  @JsonKey()
  List<ExampleItem> get ego {
    if (_ego is EqualUnmodifiableListView) return _ego;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_ego);
  }

  final List<ExampleItem> _persona;
  @override
  @JsonKey()
  List<ExampleItem> get persona {
    if (_persona is EqualUnmodifiableListView) return _persona;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_persona);
  }

  final List<ExampleItem> _shadow;
  @override
  @JsonKey()
  List<ExampleItem> get shadow {
    if (_shadow is EqualUnmodifiableListView) return _shadow;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_shadow);
  }

  final List<ExampleItem> _shadowVirtue;
  @override
  @JsonKey()
  List<ExampleItem> get shadowVirtue {
    if (_shadowVirtue is EqualUnmodifiableListView) return _shadowVirtue;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_shadowVirtue);
  }

  final List<ExampleItem> _feelingFunction;
  @override
  @JsonKey()
  List<ExampleItem> get feelingFunction {
    if (_feelingFunction is EqualUnmodifiableListView) return _feelingFunction;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_feelingFunction);
  }

  final List<ExampleItem> _erosAxis;
  @override
  @JsonKey()
  List<ExampleItem> get erosAxis {
    if (_erosAxis is EqualUnmodifiableListView) return _erosAxis;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_erosAxis);
  }

  @override
  String toString() {
    return 'IdentificationExamples(ego: $ego, persona: $persona, shadow: $shadow, shadowVirtue: $shadowVirtue, feelingFunction: $feelingFunction, erosAxis: $erosAxis)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IdentificationExamplesImpl &&
            const DeepCollectionEquality().equals(other._ego, _ego) &&
            const DeepCollectionEquality().equals(other._persona, _persona) &&
            const DeepCollectionEquality().equals(other._shadow, _shadow) &&
            const DeepCollectionEquality().equals(
              other._shadowVirtue,
              _shadowVirtue,
            ) &&
            const DeepCollectionEquality().equals(
              other._feelingFunction,
              _feelingFunction,
            ) &&
            const DeepCollectionEquality().equals(other._erosAxis, _erosAxis));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    const DeepCollectionEquality().hash(_ego),
    const DeepCollectionEquality().hash(_persona),
    const DeepCollectionEquality().hash(_shadow),
    const DeepCollectionEquality().hash(_shadowVirtue),
    const DeepCollectionEquality().hash(_feelingFunction),
    const DeepCollectionEquality().hash(_erosAxis),
  );

  /// Create a copy of IdentificationExamples
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IdentificationExamplesImplCopyWith<_$IdentificationExamplesImpl>
  get copyWith =>
      __$$IdentificationExamplesImplCopyWithImpl<_$IdentificationExamplesImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$IdentificationExamplesImplToJson(this);
  }
}

abstract class _IdentificationExamples implements IdentificationExamples {
  const factory _IdentificationExamples({
    final List<ExampleItem> ego,
    final List<ExampleItem> persona,
    final List<ExampleItem> shadow,
    final List<ExampleItem> shadowVirtue,
    final List<ExampleItem> feelingFunction,
    final List<ExampleItem> erosAxis,
  }) = _$IdentificationExamplesImpl;

  factory _IdentificationExamples.fromJson(Map<String, dynamic> json) =
      _$IdentificationExamplesImpl.fromJson;

  @override
  List<ExampleItem> get ego;
  @override
  List<ExampleItem> get persona;
  @override
  List<ExampleItem> get shadow;
  @override
  List<ExampleItem> get shadowVirtue;
  @override
  List<ExampleItem> get feelingFunction;
  @override
  List<ExampleItem> get erosAxis;

  /// Create a copy of IdentificationExamples
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IdentificationExamplesImplCopyWith<_$IdentificationExamplesImpl>
  get copyWith => throw _privateConstructorUsedError;
}

LifeDomainsExamples _$LifeDomainsExamplesFromJson(Map<String, dynamic> json) {
  return _LifeDomainsExamples.fromJson(json);
}

/// @nodoc
mixin _$LifeDomainsExamples {
  List<ExampleItem> get work => throw _privateConstructorUsedError;
  List<ExampleItem> get leadership => throw _privateConstructorUsedError;
  List<ExampleItem> get truth => throw _privateConstructorUsedError;
  List<ExampleItem> get intimacy => throw _privateConstructorUsedError;
  List<ExampleItem> get social => throw _privateConstructorUsedError;
  List<ExampleItem> get innerLife => throw _privateConstructorUsedError;

  /// Serializes this LifeDomainsExamples to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of LifeDomainsExamples
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LifeDomainsExamplesCopyWith<LifeDomainsExamples> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LifeDomainsExamplesCopyWith<$Res> {
  factory $LifeDomainsExamplesCopyWith(
    LifeDomainsExamples value,
    $Res Function(LifeDomainsExamples) then,
  ) = _$LifeDomainsExamplesCopyWithImpl<$Res, LifeDomainsExamples>;
  @useResult
  $Res call({
    List<ExampleItem> work,
    List<ExampleItem> leadership,
    List<ExampleItem> truth,
    List<ExampleItem> intimacy,
    List<ExampleItem> social,
    List<ExampleItem> innerLife,
  });
}

/// @nodoc
class _$LifeDomainsExamplesCopyWithImpl<$Res, $Val extends LifeDomainsExamples>
    implements $LifeDomainsExamplesCopyWith<$Res> {
  _$LifeDomainsExamplesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LifeDomainsExamples
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? work = null,
    Object? leadership = null,
    Object? truth = null,
    Object? intimacy = null,
    Object? social = null,
    Object? innerLife = null,
  }) {
    return _then(
      _value.copyWith(
            work: null == work
                ? _value.work
                : work // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            leadership: null == leadership
                ? _value.leadership
                : leadership // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            truth: null == truth
                ? _value.truth
                : truth // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            intimacy: null == intimacy
                ? _value.intimacy
                : intimacy // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            social: null == social
                ? _value.social
                : social // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
            innerLife: null == innerLife
                ? _value.innerLife
                : innerLife // ignore: cast_nullable_to_non_nullable
                      as List<ExampleItem>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$LifeDomainsExamplesImplCopyWith<$Res>
    implements $LifeDomainsExamplesCopyWith<$Res> {
  factory _$$LifeDomainsExamplesImplCopyWith(
    _$LifeDomainsExamplesImpl value,
    $Res Function(_$LifeDomainsExamplesImpl) then,
  ) = __$$LifeDomainsExamplesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    List<ExampleItem> work,
    List<ExampleItem> leadership,
    List<ExampleItem> truth,
    List<ExampleItem> intimacy,
    List<ExampleItem> social,
    List<ExampleItem> innerLife,
  });
}

/// @nodoc
class __$$LifeDomainsExamplesImplCopyWithImpl<$Res>
    extends _$LifeDomainsExamplesCopyWithImpl<$Res, _$LifeDomainsExamplesImpl>
    implements _$$LifeDomainsExamplesImplCopyWith<$Res> {
  __$$LifeDomainsExamplesImplCopyWithImpl(
    _$LifeDomainsExamplesImpl _value,
    $Res Function(_$LifeDomainsExamplesImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of LifeDomainsExamples
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? work = null,
    Object? leadership = null,
    Object? truth = null,
    Object? intimacy = null,
    Object? social = null,
    Object? innerLife = null,
  }) {
    return _then(
      _$LifeDomainsExamplesImpl(
        work: null == work
            ? _value._work
            : work // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        leadership: null == leadership
            ? _value._leadership
            : leadership // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        truth: null == truth
            ? _value._truth
            : truth // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        intimacy: null == intimacy
            ? _value._intimacy
            : intimacy // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        social: null == social
            ? _value._social
            : social // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
        innerLife: null == innerLife
            ? _value._innerLife
            : innerLife // ignore: cast_nullable_to_non_nullable
                  as List<ExampleItem>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$LifeDomainsExamplesImpl implements _LifeDomainsExamples {
  const _$LifeDomainsExamplesImpl({
    final List<ExampleItem> work = const [],
    final List<ExampleItem> leadership = const [],
    final List<ExampleItem> truth = const [],
    final List<ExampleItem> intimacy = const [],
    final List<ExampleItem> social = const [],
    final List<ExampleItem> innerLife = const [],
  }) : _work = work,
       _leadership = leadership,
       _truth = truth,
       _intimacy = intimacy,
       _social = social,
       _innerLife = innerLife;

  factory _$LifeDomainsExamplesImpl.fromJson(Map<String, dynamic> json) =>
      _$$LifeDomainsExamplesImplFromJson(json);

  final List<ExampleItem> _work;
  @override
  @JsonKey()
  List<ExampleItem> get work {
    if (_work is EqualUnmodifiableListView) return _work;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_work);
  }

  final List<ExampleItem> _leadership;
  @override
  @JsonKey()
  List<ExampleItem> get leadership {
    if (_leadership is EqualUnmodifiableListView) return _leadership;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_leadership);
  }

  final List<ExampleItem> _truth;
  @override
  @JsonKey()
  List<ExampleItem> get truth {
    if (_truth is EqualUnmodifiableListView) return _truth;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_truth);
  }

  final List<ExampleItem> _intimacy;
  @override
  @JsonKey()
  List<ExampleItem> get intimacy {
    if (_intimacy is EqualUnmodifiableListView) return _intimacy;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_intimacy);
  }

  final List<ExampleItem> _social;
  @override
  @JsonKey()
  List<ExampleItem> get social {
    if (_social is EqualUnmodifiableListView) return _social;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_social);
  }

  final List<ExampleItem> _innerLife;
  @override
  @JsonKey()
  List<ExampleItem> get innerLife {
    if (_innerLife is EqualUnmodifiableListView) return _innerLife;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_innerLife);
  }

  @override
  String toString() {
    return 'LifeDomainsExamples(work: $work, leadership: $leadership, truth: $truth, intimacy: $intimacy, social: $social, innerLife: $innerLife)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LifeDomainsExamplesImpl &&
            const DeepCollectionEquality().equals(other._work, _work) &&
            const DeepCollectionEquality().equals(
              other._leadership,
              _leadership,
            ) &&
            const DeepCollectionEquality().equals(other._truth, _truth) &&
            const DeepCollectionEquality().equals(other._intimacy, _intimacy) &&
            const DeepCollectionEquality().equals(other._social, _social) &&
            const DeepCollectionEquality().equals(
              other._innerLife,
              _innerLife,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    const DeepCollectionEquality().hash(_work),
    const DeepCollectionEquality().hash(_leadership),
    const DeepCollectionEquality().hash(_truth),
    const DeepCollectionEquality().hash(_intimacy),
    const DeepCollectionEquality().hash(_social),
    const DeepCollectionEquality().hash(_innerLife),
  );

  /// Create a copy of LifeDomainsExamples
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LifeDomainsExamplesImplCopyWith<_$LifeDomainsExamplesImpl> get copyWith =>
      __$$LifeDomainsExamplesImplCopyWithImpl<_$LifeDomainsExamplesImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$LifeDomainsExamplesImplToJson(this);
  }
}

abstract class _LifeDomainsExamples implements LifeDomainsExamples {
  const factory _LifeDomainsExamples({
    final List<ExampleItem> work,
    final List<ExampleItem> leadership,
    final List<ExampleItem> truth,
    final List<ExampleItem> intimacy,
    final List<ExampleItem> social,
    final List<ExampleItem> innerLife,
  }) = _$LifeDomainsExamplesImpl;

  factory _LifeDomainsExamples.fromJson(Map<String, dynamic> json) =
      _$LifeDomainsExamplesImpl.fromJson;

  @override
  List<ExampleItem> get work;
  @override
  List<ExampleItem> get leadership;
  @override
  List<ExampleItem> get truth;
  @override
  List<ExampleItem> get intimacy;
  @override
  List<ExampleItem> get social;
  @override
  List<ExampleItem> get innerLife;

  /// Create a copy of LifeDomainsExamples
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LifeDomainsExamplesImplCopyWith<_$LifeDomainsExamplesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ExampleItem _$ExampleItemFromJson(Map<String, dynamic> json) {
  return _ExampleItem.fromJson(json);
}

/// @nodoc
mixin _$ExampleItem {
  String get characterName => throw _privateConstructorUsedError;
  ExampleReference get reference => throw _privateConstructorUsedError;
  String get situation => throw _privateConstructorUsedError;
  List<String> get actions => throw _privateConstructorUsedError;
  List<String> get outcomeAndCost => throw _privateConstructorUsedError;
  String get tier =>
      throw _privateConstructorUsedError; // A = verified, B = auto-generated
  bool get autoGenerated => throw _privateConstructorUsedError;

  /// Serializes this ExampleItem to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ExampleItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ExampleItemCopyWith<ExampleItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExampleItemCopyWith<$Res> {
  factory $ExampleItemCopyWith(
    ExampleItem value,
    $Res Function(ExampleItem) then,
  ) = _$ExampleItemCopyWithImpl<$Res, ExampleItem>;
  @useResult
  $Res call({
    String characterName,
    ExampleReference reference,
    String situation,
    List<String> actions,
    List<String> outcomeAndCost,
    String tier,
    bool autoGenerated,
  });

  $ExampleReferenceCopyWith<$Res> get reference;
}

/// @nodoc
class _$ExampleItemCopyWithImpl<$Res, $Val extends ExampleItem>
    implements $ExampleItemCopyWith<$Res> {
  _$ExampleItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ExampleItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? characterName = null,
    Object? reference = null,
    Object? situation = null,
    Object? actions = null,
    Object? outcomeAndCost = null,
    Object? tier = null,
    Object? autoGenerated = null,
  }) {
    return _then(
      _value.copyWith(
            characterName: null == characterName
                ? _value.characterName
                : characterName // ignore: cast_nullable_to_non_nullable
                      as String,
            reference: null == reference
                ? _value.reference
                : reference // ignore: cast_nullable_to_non_nullable
                      as ExampleReference,
            situation: null == situation
                ? _value.situation
                : situation // ignore: cast_nullable_to_non_nullable
                      as String,
            actions: null == actions
                ? _value.actions
                : actions // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            outcomeAndCost: null == outcomeAndCost
                ? _value.outcomeAndCost
                : outcomeAndCost // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            tier: null == tier
                ? _value.tier
                : tier // ignore: cast_nullable_to_non_nullable
                      as String,
            autoGenerated: null == autoGenerated
                ? _value.autoGenerated
                : autoGenerated // ignore: cast_nullable_to_non_nullable
                      as bool,
          )
          as $Val,
    );
  }

  /// Create a copy of ExampleItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ExampleReferenceCopyWith<$Res> get reference {
    return $ExampleReferenceCopyWith<$Res>(_value.reference, (value) {
      return _then(_value.copyWith(reference: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExampleItemImplCopyWith<$Res>
    implements $ExampleItemCopyWith<$Res> {
  factory _$$ExampleItemImplCopyWith(
    _$ExampleItemImpl value,
    $Res Function(_$ExampleItemImpl) then,
  ) = __$$ExampleItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String characterName,
    ExampleReference reference,
    String situation,
    List<String> actions,
    List<String> outcomeAndCost,
    String tier,
    bool autoGenerated,
  });

  @override
  $ExampleReferenceCopyWith<$Res> get reference;
}

/// @nodoc
class __$$ExampleItemImplCopyWithImpl<$Res>
    extends _$ExampleItemCopyWithImpl<$Res, _$ExampleItemImpl>
    implements _$$ExampleItemImplCopyWith<$Res> {
  __$$ExampleItemImplCopyWithImpl(
    _$ExampleItemImpl _value,
    $Res Function(_$ExampleItemImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ExampleItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? characterName = null,
    Object? reference = null,
    Object? situation = null,
    Object? actions = null,
    Object? outcomeAndCost = null,
    Object? tier = null,
    Object? autoGenerated = null,
  }) {
    return _then(
      _$ExampleItemImpl(
        characterName: null == characterName
            ? _value.characterName
            : characterName // ignore: cast_nullable_to_non_nullable
                  as String,
        reference: null == reference
            ? _value.reference
            : reference // ignore: cast_nullable_to_non_nullable
                  as ExampleReference,
        situation: null == situation
            ? _value.situation
            : situation // ignore: cast_nullable_to_non_nullable
                  as String,
        actions: null == actions
            ? _value._actions
            : actions // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        outcomeAndCost: null == outcomeAndCost
            ? _value._outcomeAndCost
            : outcomeAndCost // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        tier: null == tier
            ? _value.tier
            : tier // ignore: cast_nullable_to_non_nullable
                  as String,
        autoGenerated: null == autoGenerated
            ? _value.autoGenerated
            : autoGenerated // ignore: cast_nullable_to_non_nullable
                  as bool,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ExampleItemImpl implements _ExampleItem {
  const _$ExampleItemImpl({
    required this.characterName,
    required this.reference,
    required this.situation,
    required final List<String> actions,
    required final List<String> outcomeAndCost,
    this.tier = 'A',
    this.autoGenerated = false,
  }) : _actions = actions,
       _outcomeAndCost = outcomeAndCost;

  factory _$ExampleItemImpl.fromJson(Map<String, dynamic> json) =>
      _$$ExampleItemImplFromJson(json);

  @override
  final String characterName;
  @override
  final ExampleReference reference;
  @override
  final String situation;
  final List<String> _actions;
  @override
  List<String> get actions {
    if (_actions is EqualUnmodifiableListView) return _actions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_actions);
  }

  final List<String> _outcomeAndCost;
  @override
  List<String> get outcomeAndCost {
    if (_outcomeAndCost is EqualUnmodifiableListView) return _outcomeAndCost;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_outcomeAndCost);
  }

  @override
  @JsonKey()
  final String tier;
  // A = verified, B = auto-generated
  @override
  @JsonKey()
  final bool autoGenerated;

  @override
  String toString() {
    return 'ExampleItem(characterName: $characterName, reference: $reference, situation: $situation, actions: $actions, outcomeAndCost: $outcomeAndCost, tier: $tier, autoGenerated: $autoGenerated)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExampleItemImpl &&
            (identical(other.characterName, characterName) ||
                other.characterName == characterName) &&
            (identical(other.reference, reference) ||
                other.reference == reference) &&
            (identical(other.situation, situation) ||
                other.situation == situation) &&
            const DeepCollectionEquality().equals(other._actions, _actions) &&
            const DeepCollectionEquality().equals(
              other._outcomeAndCost,
              _outcomeAndCost,
            ) &&
            (identical(other.tier, tier) || other.tier == tier) &&
            (identical(other.autoGenerated, autoGenerated) ||
                other.autoGenerated == autoGenerated));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    characterName,
    reference,
    situation,
    const DeepCollectionEquality().hash(_actions),
    const DeepCollectionEquality().hash(_outcomeAndCost),
    tier,
    autoGenerated,
  );

  /// Create a copy of ExampleItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExampleItemImplCopyWith<_$ExampleItemImpl> get copyWith =>
      __$$ExampleItemImplCopyWithImpl<_$ExampleItemImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExampleItemImplToJson(this);
  }
}

abstract class _ExampleItem implements ExampleItem {
  const factory _ExampleItem({
    required final String characterName,
    required final ExampleReference reference,
    required final String situation,
    required final List<String> actions,
    required final List<String> outcomeAndCost,
    final String tier,
    final bool autoGenerated,
  }) = _$ExampleItemImpl;

  factory _ExampleItem.fromJson(Map<String, dynamic> json) =
      _$ExampleItemImpl.fromJson;

  @override
  String get characterName;
  @override
  ExampleReference get reference;
  @override
  String get situation;
  @override
  List<String> get actions;
  @override
  List<String> get outcomeAndCost;
  @override
  String get tier; // A = verified, B = auto-generated
  @override
  bool get autoGenerated;

  /// Create a copy of ExampleItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExampleItemImplCopyWith<_$ExampleItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ExampleReference _$ExampleReferenceFromJson(Map<String, dynamic> json) {
  return _ExampleReference.fromJson(json);
}

/// @nodoc
mixin _$ExampleReference {
  String get title => throw _privateConstructorUsedError;
  @YearToStringConverter()
  String get year => throw _privateConstructorUsedError;
  String get medium => throw _privateConstructorUsedError;

  /// Serializes this ExampleReference to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ExampleReference
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ExampleReferenceCopyWith<ExampleReference> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExampleReferenceCopyWith<$Res> {
  factory $ExampleReferenceCopyWith(
    ExampleReference value,
    $Res Function(ExampleReference) then,
  ) = _$ExampleReferenceCopyWithImpl<$Res, ExampleReference>;
  @useResult
  $Res call({
    String title,
    @YearToStringConverter() String year,
    String medium,
  });
}

/// @nodoc
class _$ExampleReferenceCopyWithImpl<$Res, $Val extends ExampleReference>
    implements $ExampleReferenceCopyWith<$Res> {
  _$ExampleReferenceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ExampleReference
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? year = null,
    Object? medium = null,
  }) {
    return _then(
      _value.copyWith(
            title: null == title
                ? _value.title
                : title // ignore: cast_nullable_to_non_nullable
                      as String,
            year: null == year
                ? _value.year
                : year // ignore: cast_nullable_to_non_nullable
                      as String,
            medium: null == medium
                ? _value.medium
                : medium // ignore: cast_nullable_to_non_nullable
                      as String,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$ExampleReferenceImplCopyWith<$Res>
    implements $ExampleReferenceCopyWith<$Res> {
  factory _$$ExampleReferenceImplCopyWith(
    _$ExampleReferenceImpl value,
    $Res Function(_$ExampleReferenceImpl) then,
  ) = __$$ExampleReferenceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String title,
    @YearToStringConverter() String year,
    String medium,
  });
}

/// @nodoc
class __$$ExampleReferenceImplCopyWithImpl<$Res>
    extends _$ExampleReferenceCopyWithImpl<$Res, _$ExampleReferenceImpl>
    implements _$$ExampleReferenceImplCopyWith<$Res> {
  __$$ExampleReferenceImplCopyWithImpl(
    _$ExampleReferenceImpl _value,
    $Res Function(_$ExampleReferenceImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ExampleReference
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? year = null,
    Object? medium = null,
  }) {
    return _then(
      _$ExampleReferenceImpl(
        title: null == title
            ? _value.title
            : title // ignore: cast_nullable_to_non_nullable
                  as String,
        year: null == year
            ? _value.year
            : year // ignore: cast_nullable_to_non_nullable
                  as String,
        medium: null == medium
            ? _value.medium
            : medium // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ExampleReferenceImpl implements _ExampleReference {
  const _$ExampleReferenceImpl({
    required this.title,
    @YearToStringConverter() required this.year,
    required this.medium,
  });

  factory _$ExampleReferenceImpl.fromJson(Map<String, dynamic> json) =>
      _$$ExampleReferenceImplFromJson(json);

  @override
  final String title;
  @override
  @YearToStringConverter()
  final String year;
  @override
  final String medium;

  @override
  String toString() {
    return 'ExampleReference(title: $title, year: $year, medium: $medium)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExampleReferenceImpl &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.year, year) || other.year == year) &&
            (identical(other.medium, medium) || other.medium == medium));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, title, year, medium);

  /// Create a copy of ExampleReference
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExampleReferenceImplCopyWith<_$ExampleReferenceImpl> get copyWith =>
      __$$ExampleReferenceImplCopyWithImpl<_$ExampleReferenceImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$ExampleReferenceImplToJson(this);
  }
}

abstract class _ExampleReference implements ExampleReference {
  const factory _ExampleReference({
    required final String title,
    @YearToStringConverter() required final String year,
    required final String medium,
  }) = _$ExampleReferenceImpl;

  factory _ExampleReference.fromJson(Map<String, dynamic> json) =
      _$ExampleReferenceImpl.fromJson;

  @override
  String get title;
  @override
  @YearToStringConverter()
  String get year;
  @override
  String get medium;

  /// Create a copy of ExampleReference
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExampleReferenceImplCopyWith<_$ExampleReferenceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
